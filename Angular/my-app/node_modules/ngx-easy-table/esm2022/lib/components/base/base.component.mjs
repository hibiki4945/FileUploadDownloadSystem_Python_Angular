import { moveItemInArray } from '@angular/cdk/drag-drop';
import { ChangeDetectionStrategy, Component, ContentChild, EventEmitter, HostListener, Input, Output, TemplateRef, ViewChild, } from '@angular/core';
import { API, Event } from '../..';
import { DefaultConfigService } from '../../services/config-service';
import { GroupRowsService } from '../../services/group-rows.service';
import { StyleService } from '../../services/style.service';
import { Subject } from 'rxjs';
import { CdkVirtualScrollViewport } from '@angular/cdk/scrolling';
import { filter, takeUntil, throttleTime } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/scrolling";
import * as i2 from "../../services/style.service";
import * as i3 from "@angular/common";
import * as i4 from "@angular/cdk/drag-drop";
import * as i5 from "../pagination/pagination.component";
import * as i6 from "../thead/thead.component";
import * as i7 from "ngx-pagination";
import * as i8 from "../../pipes/search-pipe";
import * as i9 from "../../pipes/render-pipe";
import * as i10 from "../../pipes/global-search-pipe";
import * as i11 from "../../pipes/sort.pipe";
class BaseComponent {
    onContextMenuClick(targetElement) {
        if (this.contextMenu && !this.contextMenu.nativeElement.contains(targetElement)) {
            this.rowContextMenuPosition = {
                top: null,
                left: null,
                value: null,
            };
        }
    }
    constructor(cdr, scrollDispatcher, styleService) {
        this.cdr = cdr;
        this.scrollDispatcher = scrollDispatcher;
        this.styleService = styleService;
        this.unsubscribe = new Subject();
        this.filterCount = -1;
        this.filteredCountSubject = new Subject();
        this.tableClass = null;
        this.grouped = [];
        this.isSelected = false;
        this.page = 1;
        this.count = 0;
        this.sortState = new Map();
        this.sortKey = null;
        this.rowContextMenuPosition = {
            top: null,
            left: null,
            value: null,
        };
        this.sortBy = {
            key: '',
            order: 'asc',
        };
        this.selectedDetailsTemplateRowId = new Set();
        this.selectedCheckboxes = new Set();
        this.id = 'table';
        this.event = new EventEmitter();
        this.filteredCountSubject.pipe(takeUntil(this.unsubscribe)).subscribe((count) => {
            setTimeout(() => {
                this.filterCount = count;
                this.cdr.detectChanges();
            });
        });
    }
    ngOnInit() {
        if (!this.columns) {
            console.error('[columns] property required!');
        }
        if (this.configuration) {
            this.config = this.configuration;
        }
        else {
            this.config = DefaultConfigService.config;
        }
        this.limit = this.config.rows;
        if (this.groupRowsBy) {
            this.grouped = GroupRowsService.doGroupRows(this.data, this.groupRowsBy);
        }
        this.doDecodePersistedState();
    }
    ngOnDestroy() {
        this.unsubscribe.next();
        this.unsubscribe.complete();
    }
    ngAfterViewInit() {
        const throttleValue = this.config.infiniteScrollThrottleTime
            ? this.config.infiniteScrollThrottleTime
            : 200;
        this.scrollDispatcher
            .scrolled()
            .pipe(throttleTime(throttleValue), filter((event) => {
            return (!!event &&
                this.viewPort &&
                this.viewPort.getRenderedRange().end === this.viewPort.getDataLength());
        }), takeUntil(this.unsubscribe))
            .subscribe(() => {
            this.emitEvent(Event.onInfiniteScrollEnd, null);
        });
    }
    ngOnChanges(changes) {
        const { configuration, data, pagination, groupRowsBy } = changes;
        this.toggleRowIndex = changes.toggleRowIndex;
        if (configuration && configuration.currentValue) {
            this.config = configuration.currentValue;
        }
        if (data && data.currentValue) {
            this.doApplyData(data);
        }
        if (pagination && pagination.currentValue) {
            const { count, limit, offset } = pagination.currentValue;
            this.count = count;
            this.limit = limit;
            this.page = offset;
        }
        if (groupRowsBy && groupRowsBy.currentValue) {
            this.grouped = GroupRowsService.doGroupRows(this.data, this.groupRowsBy);
        }
        if (this.toggleRowIndex && this.toggleRowIndex.currentValue) {
            const row = this.toggleRowIndex.currentValue;
            this.collapseRow(row.index);
        }
    }
    orderBy(column) {
        if (typeof column.orderEnabled !== 'undefined' && !column.orderEnabled) {
            return;
        }
        this.sortKey = column.key;
        if (!this.config.orderEnabled || this.sortKey === '') {
            return;
        }
        this.setColumnOrder(column);
        if (!this.config.orderEventOnly && !column.orderEventOnly) {
            this.sortBy.key = this.sortKey;
            this.sortBy.order = this.sortState.get(this.sortKey);
        }
        else {
            this.sortBy.key = '';
            this.sortBy.order = '';
        }
        if (!this.config.serverPagination) {
            this.data = [...this.data];
            this.sortBy = { ...this.sortBy };
        }
        const value = {
            key: this.sortKey,
            order: this.sortState.get(this.sortKey),
        };
        this.emitEvent(Event.onOrder, value);
    }
    onClick($event, row, key, colIndex, rowIndex) {
        if (this.config.selectRow) {
            this.selectedRow = rowIndex;
        }
        if (this.config.selectCol && `${colIndex}`) {
            this.selectedCol = colIndex;
        }
        if (this.config.selectCell && `${colIndex}`) {
            this.selectedRow = rowIndex;
            this.selectedCol = colIndex;
        }
        if (this.config.clickEvent) {
            const value = {
                event: $event,
                row,
                key,
                rowId: rowIndex,
                colId: colIndex,
            };
            this.emitEvent(Event.onClick, value);
        }
    }
    onDoubleClick($event, row, key, colIndex, rowIndex) {
        const value = {
            event: $event,
            row,
            key,
            rowId: rowIndex,
            colId: colIndex,
        };
        this.emitEvent(Event.onDoubleClick, value);
    }
    onCheckboxSelect($event, row, rowIndex) {
        const value = {
            event: $event,
            row,
            rowId: rowIndex,
        };
        this.emitEvent(Event.onCheckboxSelect, value);
    }
    onRadioSelect($event, row, rowIndex) {
        const value = {
            event: $event,
            row,
            rowId: rowIndex,
        };
        this.emitEvent(Event.onRadioSelect, value);
    }
    onSelectAll() {
        this.isSelected = !this.isSelected;
        this.emitEvent(Event.onSelectAll, this.isSelected);
    }
    onSearch($event) {
        if (!this.config.serverPagination) {
            this.term = $event;
        }
        this.emitEvent(Event.onSearch, $event);
    }
    onGlobalSearch(value) {
        if (!this.config.serverPagination) {
            this.globalSearchTerm = value;
        }
        this.emitEvent(Event.onGlobalSearch, value);
    }
    onPagination(pagination) {
        this.page = pagination.page;
        this.limit = pagination.limit;
        this.config.rows = pagination.limit;
        this.emitEvent(Event.onPagination, pagination);
    }
    toggleCheckbox(rowIndex) {
        this.selectedCheckboxes.has(rowIndex)
            ? this.selectedCheckboxes.delete(rowIndex)
            : this.selectedCheckboxes.add(rowIndex);
    }
    collapseRow(rowIndex) {
        if (this.selectedDetailsTemplateRowId.has(rowIndex)) {
            this.selectedDetailsTemplateRowId.delete(rowIndex);
            this.emitEvent(Event.onRowCollapsedHide, rowIndex);
        }
        else {
            this.selectedDetailsTemplateRowId.add(rowIndex);
            this.emitEvent(Event.onRowCollapsedShow, rowIndex);
        }
    }
    doDecodePersistedState() {
        if (!this.config.persistState) {
            return;
        }
        const pagination = localStorage.getItem(Event.onPagination);
        const sort = localStorage.getItem(Event.onOrder);
        const search = localStorage.getItem(Event.onSearch);
        if (pagination) {
            this.onPagination(JSON.parse(pagination));
        }
        if (sort) {
            const { key, order } = JSON.parse(sort);
            this.bindApi({
                type: API.sortBy,
                value: { column: key, order },
            });
        }
        if (search) {
            this.bindApi({
                type: API.setInputValue,
                value: JSON.parse(search),
            });
        }
    }
    isRowCollapsed(rowIndex) {
        if (this.config.collapseAllRows) {
            return true;
        }
        return this.selectedDetailsTemplateRowId.has(rowIndex);
    }
    get loadingHeight() {
        const table = document.getElementById(this.id);
        if (table && table.rows && table.rows.length > 3) {
            const searchEnabled = this.config.searchEnabled ? 1 : 0;
            const headerEnabled = this.config.headerEnabled ? 1 : 0;
            const borderTrHeight = 1;
            const borderDivHeight = 2;
            return ((table.rows.length - searchEnabled - headerEnabled) *
                (table.rows[3].offsetHeight - borderTrHeight) -
                borderDivHeight);
        }
        return 30;
    }
    get arrowDefinition() {
        return this.config.showDetailsArrow || typeof this.config.showDetailsArrow === 'undefined';
    }
    onRowContextMenu($event, row, key, colIndex, rowIndex) {
        if (!this.config.showContextMenu) {
            return;
        }
        $event.preventDefault();
        const value = {
            event: $event,
            row,
            key,
            rowId: rowIndex,
            colId: colIndex,
        };
        this.rowContextMenuPosition = {
            top: `${$event.pageY - 10}px`,
            left: `${$event.pageX - 10}px`,
            value,
        };
        this.emitEvent(Event.onRowContextMenu, value);
    }
    doApplyData(data) {
        const order = this.columns.find((c) => !!c.orderBy);
        if (order) {
            this.sortState.set(this.sortKey, order.orderBy === 'asc' ? 'desc' : 'asc');
            this.orderBy(order);
        }
        else {
            this.data = [...data.currentValue];
        }
    }
    onDragStart(event) {
        this.emitEvent(Event.onReorderStart, event);
    }
    onDrop(event) {
        this.emitEvent(Event.onRowDrop, event);
        moveItemInArray(this.data, event.previousIndex, event.currentIndex);
    }
    // DO NOT REMOVE. It is called from parent component. See src/app/demo/api-doc/api-doc.component.ts
    apiEvent(event) {
        return this.bindApi(event);
    }
    /* eslint-disable */
    bindApi(event) {
        switch (event.type) {
            case API.rowContextMenuClicked:
                this.rowContextMenuPosition = {
                    top: null,
                    left: null,
                    value: null,
                };
                break;
            case API.toggleRowIndex:
                this.collapseRow(event.value);
                break;
            case API.toggleCheckbox:
                this.toggleCheckbox(event.value);
                break;
            case API.setInputValue:
                if (this.config.searchEnabled) {
                    event.value.forEach((input) => {
                        const element = document.getElementById(`search_${input.key}`);
                        if (!element) {
                            console.error(`Column '${input.key}' not available in the DOM. Have you misspelled a name?`);
                        }
                        else {
                            element.value = input.value;
                        }
                    });
                }
                this.onSearch(event.value);
                this.cdr.markForCheck();
                break;
            case API.onGlobalSearch:
                this.onGlobalSearch(event.value);
                this.cdr.markForCheck();
                break;
            case API.setRowClass:
                if (Array.isArray(event.value)) {
                    event.value.forEach((val) => this.styleService.setRowClass(val));
                    break;
                }
                this.styleService.setRowClass(event.value);
                this.cdr.markForCheck();
                break;
            case API.setCellClass:
                if (Array.isArray(event.value)) {
                    event.value.forEach((val) => this.styleService.setCellClass(val));
                    break;
                }
                this.styleService.setCellClass(event.value);
                break;
            case API.setRowStyle:
                if (Array.isArray(event.value)) {
                    event.value.forEach((val) => this.styleService.setRowStyle(val));
                    break;
                }
                this.styleService.setRowStyle(event.value);
                break;
            case API.setCellStyle:
                if (Array.isArray(event.value)) {
                    event.value.forEach((val) => this.styleService.setCellStyle(val));
                    break;
                }
                this.styleService.setCellStyle(event.value);
                break;
            case API.setTableClass:
                this.tableClass = event.value;
                this.cdr.markForCheck();
                break;
            case API.getPaginationTotalItems:
                return this.paginationComponent.paginationDirective.getTotalItems();
            case API.getPaginationCurrentPage:
                return this.paginationComponent.paginationDirective.getCurrent();
            case API.getPaginationLastPage:
                return this.paginationComponent.paginationDirective.getLastPage();
            case API.getNumberOfRowsPerPage:
                return this.paginationComponent.paginationDirective.isLastPage()
                    ? this.paginationComponent.paginationDirective.getTotalItems() % this.limit
                    : this.limit;
            case API.setPaginationCurrentPage:
                this.paginationComponent.paginationDirective.setCurrent(event.value);
                break;
            case API.setPaginationRange:
                this.paginationComponent.ranges = event.value;
                break;
            case API.setPaginationPreviousLabel:
                this.paginationComponent.previousLabel = event.value;
                break;
            case API.setPaginationNextLabel:
                this.paginationComponent.nextLabel = event.value;
                break;
            case API.setPaginationDisplayLimit:
                this.paginationComponent.changeLimit(event.value, true);
                break;
            case API.sortBy:
                const column = { title: '', key: event.value.column, orderBy: event.value.order };
                this.orderBy(column);
                this.cdr.detectChanges();
                break;
            default:
                break;
        }
    }
    setColumnOrder(column) {
        const key = column.key;
        switch (this.sortState.get(key)) {
            case '':
            case undefined:
                this.sortState.set(key, column.orderBy || 'desc');
                break;
            case 'asc':
                this.config.threeWaySort ? this.sortState.set(key, '') : this.sortState.set(key, 'desc');
                break;
            case 'desc':
                this.sortState.set(key, 'asc');
                break;
        }
        if (this.sortState.size > 1) {
            const temp = this.sortState.get(key);
            this.sortState.clear();
            this.sortState.set(key, temp);
        }
    }
    emitEvent(event, value) {
        this.event.emit({ event, value });
        if (this.config.persistState) {
            localStorage.setItem(event, JSON.stringify(value));
        }
        if (this.config.logger) {
            // eslint-disable-next-line no-console
            console.log({ event, value });
        }
    }
    dragEnter($event) {
        $event.preventDefault();
        $event.stopPropagation();
    }
    dragOver($event) {
        $event.preventDefault();
        $event.stopPropagation();
    }
    dragLeave($event) {
        $event.preventDefault();
        $event.stopPropagation();
    }
    drop($event) {
        $event.preventDefault();
        $event.stopPropagation();
        const file = $event.dataTransfer?.files?.[0];
        if (file?.type !== 'application/json') {
            // eslint-disable-next-line no-console
            console.log('File not allowed');
            return;
        }
        const fileReader = new FileReader();
        fileReader.onload = (event) => {
            this.data = JSON.parse(event?.target?.result);
            this.cdr.markForCheck();
        };
        fileReader.readAsText(file);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: BaseComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.ScrollDispatcher }, { token: i2.StyleService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.0.4", type: BaseComponent, selector: "ngx-table", inputs: { configuration: "configuration", data: "data", pagination: "pagination", groupRowsBy: "groupRowsBy", id: "id", toggleRowIndex: "toggleRowIndex", detailsTemplate: "detailsTemplate", summaryTemplate: "summaryTemplate", groupRowsHeaderTemplate: "groupRowsHeaderTemplate", filtersTemplate: "filtersTemplate", selectAllTemplate: "selectAllTemplate", noResultsTemplate: "noResultsTemplate", loadingTemplate: "loadingTemplate", additionalActionsTemplate: "additionalActionsTemplate", rowContextMenu: "rowContextMenu", columns: "columns" }, outputs: { event: "event" }, host: { listeners: { "document:click": "onContextMenuClick($event.target)" } }, providers: [DefaultConfigService, GroupRowsService, StyleService], queries: [{ propertyName: "rowTemplate", first: true, predicate: TemplateRef, descendants: true }], viewQueries: [{ propertyName: "paginationComponent", first: true, predicate: ["paginationComponent"], descendants: true }, { propertyName: "contextMenu", first: true, predicate: ["contextMenu"], descendants: true }, { propertyName: "table", first: true, predicate: ["table"], descendants: true }, { propertyName: "viewPort", first: true, predicate: CdkVirtualScrollViewport, descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div\n  class=\"ngx-container\"\n  [class.ngx-container--dark]=\"config.tableLayout.theme === 'dark'\"\n  (dragenter)=\"dragEnter($event)\"\n  (dragover)=\"dragOver($event)\"\n  (dragleave)=\"dragLeave($event)\"\n  (drop)=\"drop($event)\"\n>\n  <table\n    [id]=\"id\"\n    #table\n    [ngClass]=\"tableClass === null || tableClass === '' ? 'ngx-table' : tableClass\"\n    [class.ngx-table__table--tiny]=\"config.tableLayout.style === 'tiny'\"\n    [class.ngx-table__table--normal]=\"config.tableLayout.style === 'normal'\"\n    [class.ngx-table__table--big]=\"config.tableLayout.style === 'big'\"\n    [class.ngx-table__table--borderless]=\"config.tableLayout.borderless\"\n    [class.ngx-table__table--dark]=\"config.tableLayout.theme === 'dark'\"\n    [class.ngx-table__table--hoverable]=\"config.tableLayout.hover\"\n    [class.ngx-table__table--striped]=\"config.tableLayout.striped\"\n    [class.ngx-table__horizontal-scroll]=\"config.horizontalScroll && !config.isLoading\"\n  >\n    <thead\n      [class.ngx-infinite-scroll-viewport-thead]=\"config.infiniteScroll\"\n      table-thead\n      [config]=\"config\"\n      [sortKey]=\"sortKey\"\n      [sortState]=\"sortState\"\n      [selectAllTemplate]=\"selectAllTemplate\"\n      [filtersTemplate]=\"filtersTemplate\"\n      [additionalActionsTemplate]=\"additionalActionsTemplate\"\n      [columns]=\"columns\"\n      (selectAll)=\"onSelectAll()\"\n      (filter)=\"onSearch($event)\"\n      (order)=\"orderBy($event)\"\n      (event)=\"emitEvent($event.event, $event.value)\"\n    ></thead>\n    <tbody *ngIf=\"data && !config.isLoading && !config.rowReorder\">\n      <ng-container *ngIf=\"rowTemplate\">\n        <ul\n          class=\"ngx-table__table-row-context-menu\"\n          [ngStyle]=\"{\n            position: 'absolute',\n            top: rowContextMenuPosition.top,\n            left: rowContextMenuPosition.left\n          }\"\n          *ngIf=\"rowContextMenuPosition.top\"\n        >\n          <ng-container\n            [ngTemplateOutlet]=\"rowContextMenu\"\n            [ngTemplateOutletContext]=\"{ $implicit: rowContextMenuPosition.value }\"\n          >\n          </ng-container>\n        </ul>\n        <ng-container *ngIf=\"!config.infiniteScroll\">\n          <ng-container\n            *ngFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject\n                | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id }\n            \"\n          >\n            <tr\n              (click)=\"onClick($event, row, '', null, data.indexOf(row))\"\n              #contextMenu\n              (contextmenu)=\"onRowContextMenu($event, row, '', null, data.indexOf(row))\"\n              (dblclick)=\"onDoubleClick($event, row, '', null, data.indexOf(row))\"\n              [class.ngx-table__table-row--selected]=\"\n                data.indexOf(row) === selectedRow && !config.selectCell\n              \"\n            >\n              <ng-container\n                [ngTemplateOutlet]=\"rowTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: row, index: data.indexOf(row) }\"\n              >\n              </ng-container>\n              <td *ngIf=\"config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(data.indexOf(row))\n                      ? 'ngx-icon-arrow-down'\n                      : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(data.indexOf(row))\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(data.indexOf(row))) ||\n                config.collapseAllRows\n              \"\n            >\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: data.indexOf(row) }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </ng-container>\n        <cdk-virtual-scroll-viewport\n          itemSize=\"50\"\n          *ngIf=\"config.infiniteScroll\"\n          class=\"ngx-infinite-scroll-viewport\"\n        >\n          <ng-container\n            *cdkVirtualFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject;\n              let rowIndex = index\n            \"\n          >\n            <tr\n              (click)=\"onClick($event, row, '', null, rowIndex)\"\n              #contextMenu\n              (contextmenu)=\"onRowContextMenu($event, row, '', null, rowIndex)\"\n              (dblclick)=\"onDoubleClick($event, row, '', null, rowIndex)\"\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <ng-container\n                [ngTemplateOutlet]=\"rowTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n              >\n              </ng-container>\n              <td *ngIf=\"config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </cdk-virtual-scroll-viewport>\n      </ng-container>\n      <ng-container *ngIf=\"!rowTemplate && !config.groupRows\">\n        <ul\n          class=\"ngx-table__table-row-context-menu\"\n          [ngStyle]=\"{\n            position: 'absolute',\n            top: rowContextMenuPosition.top,\n            left: rowContextMenuPosition.left\n          }\"\n          *ngIf=\"rowContextMenuPosition.top\"\n        >\n          <ng-container\n            [ngTemplateOutlet]=\"rowContextMenu\"\n            [ngTemplateOutletContext]=\"{ $implicit: rowContextMenuPosition.value }\"\n          >\n          </ng-container>\n        </ul>\n        <ng-container *ngIf=\"!config.infiniteScroll\">\n          <ng-container\n            *ngFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject\n                | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id }\n            \"\n          >\n            <tr\n              [class.ngx-table__table-row--selected]=\"\n                data.indexOf(row) === selectedRow && !config.selectCell\n              \"\n            >\n              <td *ngIf=\"config.checkboxes\">\n                <label class=\"ngx-form-checkbox\">\n                  <input\n                    type=\"checkbox\"\n                    id=\"checkbox-{{ data.indexOf(row) }}\"\n                    [checked]=\"isSelected || selectedCheckboxes.has(data.indexOf(row))\"\n                    (change)=\"onCheckboxSelect($event, row, data.indexOf(row))\"\n                  />\n                  <em class=\"ngx-form-icon\"></em>\n                </label>\n              </td>\n              <td *ngIf=\"config.radio\">\n                <label>\n                  <input\n                    type=\"radio\"\n                    id=\"radio-{{ data.indexOf(row) }}\"\n                    name=\"radio\"\n                    (change)=\"onRadioSelect($event, row, data.indexOf(row))\"\n                  />\n                </label>\n              </td>\n              <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n                <td\n                  (click)=\"onClick($event, row, column.key, colIndex, data.indexOf(row))\"\n                  #contextMenu\n                  (contextmenu)=\"\n                    onRowContextMenu($event, row, column.key, colIndex, data.indexOf(row))\n                  \"\n                  (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, data.indexOf(row))\"\n                  [class.pinned-left]=\"column.pinned\"\n                  [ngClass]=\"column.cssClass ? column.cssClass.name : ''\"\n                  [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n                  [class.ngx-table__table-col--selected]=\"\n                    colIndex === selectedCol && !config.selectCell\n                  \"\n                  [class.ngx-table__table-cell--selected]=\"\n                    colIndex === selectedCol &&\n                    data.indexOf(row) === selectedRow &&\n                    !config.selectCol &&\n                    !config.selectRow\n                  \"\n                >\n                  <div *ngIf=\"!column.cellTemplate\">{{ row | render: column.key }}</div>\n                  <ng-container\n                    *ngIf=\"column.cellTemplate\"\n                    [ngTemplateOutlet]=\"column.cellTemplate\"\n                    [ngTemplateOutletContext]=\"{\n                      $implicit: row,\n                      rowIndex: data.indexOf(row),\n                      column: column\n                    }\"\n                  >\n                  </ng-container>\n                </td>\n              </ng-container>\n              <td *ngIf=\"config.additionalActions || config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(data.indexOf(row))\n                      ? 'ngx-icon-arrow-down'\n                      : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(data.indexOf(row))\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(data.indexOf(row))) ||\n                config.collapseAllRows\n              \"\n            >\n              <td *ngIf=\"config.checkboxes || config.radio\"></td>\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: data.indexOf(row) }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </ng-container>\n        <!-- infinite scroll -->\n        <cdk-virtual-scroll-viewport\n          itemSize=\"50\"\n          *ngIf=\"config.infiniteScroll\"\n          class=\"ngx-infinite-scroll-viewport\"\n        >\n          <ng-container\n            *cdkVirtualFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject;\n              let rowIndex = index\n            \"\n          >\n            <tr\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <td *ngIf=\"config.checkboxes\" width=\"3%\">\n                <label class=\"ngx-form-checkbox\">\n                  <input\n                    type=\"checkbox\"\n                    id=\"checkbox-infinite-scroll-{{ rowIndex }}\"\n                    [checked]=\"isSelected || selectedCheckboxes.has(rowIndex)\"\n                    (change)=\"onCheckboxSelect($event, row, rowIndex)\"\n                  />\n                  <em class=\"ngx-form-icon\"></em>\n                </label>\n              </td>\n              <td *ngIf=\"config.radio\" width=\"3%\">\n                <label>\n                  <input\n                    type=\"radio\"\n                    id=\"radio-infinite-scroll-{{ rowIndex }}\"\n                    name=\"radio\"\n                    (change)=\"onRadioSelect($event, row, rowIndex)\"\n                  />\n                </label>\n              </td>\n              <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n                <td\n                  (click)=\"onClick($event, row, column.key, colIndex, rowIndex)\"\n                  #contextMenu\n                  (contextmenu)=\"onRowContextMenu($event, row, column.key, colIndex, rowIndex)\"\n                  (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, rowIndex)\"\n                  [class.pinned-left]=\"column.pinned\"\n                  [ngClass]=\"column.cssClass ? column.cssClass.name : ''\"\n                  [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n                  [class.ngx-table__table-col--selected]=\"\n                    colIndex === selectedCol && !config.selectCell\n                  \"\n                  [class.ngx-table__table-cell--selected]=\"\n                    colIndex === selectedCol &&\n                    rowIndex === selectedRow &&\n                    !config.selectCol &&\n                    !config.selectRow\n                  \"\n                >\n                  <div *ngIf=\"!column.cellTemplate\">{{ row | render: column.key }}</div>\n                  <ng-container\n                    *ngIf=\"column.cellTemplate\"\n                    [ngTemplateOutlet]=\"column.cellTemplate\"\n                    [ngTemplateOutletContext]=\"{\n                      $implicit: row,\n                      rowIndex: rowIndex,\n                      column: column\n                    }\"\n                  >\n                  </ng-container>\n                </td>\n              </ng-container>\n              <td *ngIf=\"config.additionalActions || config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td *ngIf=\"config.checkboxes || config.radio\"></td>\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </cdk-virtual-scroll-viewport>\n      </ng-container>\n      <ng-container *ngIf=\"!rowTemplate && config.groupRows\">\n        <ng-container\n          *ngFor=\"\n            let group of grouped\n              | sort: sortBy:config\n              | search: term:filteredCountSubject:config\n              | global: globalSearchTerm:filteredCountSubject\n              | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n            let rowIndex = index\n          \"\n        >\n          <tr>\n            <ng-container *ngIf=\"!groupRowsHeaderTemplate\">\n              <td [attr.colspan]=\"columns.length\">\n                <div>{{ group[0][groupRowsBy] }} ({{ group.length }})</div>\n              </td>\n            </ng-container>\n            <ng-container\n              *ngIf=\"groupRowsHeaderTemplate\"\n              [ngTemplateOutlet]=\"groupRowsHeaderTemplate\"\n              [ngTemplateOutletContext]=\"{\n                total: group.length,\n                key: groupRowsBy,\n                value: group[0] ? group[0][groupRowsBy] : '',\n                group: group,\n                index: rowIndex\n              }\"\n            >\n            </ng-container>\n            <td>\n              <span\n                class=\"ngx-icon\"\n                *ngIf=\"arrowDefinition\"\n                [ngClass]=\"\n                  isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                \"\n                (click)=\"collapseRow(rowIndex)\"\n              >\n              </span>\n            </td>\n          </tr>\n          <ng-container *ngIf=\"selectedDetailsTemplateRowId.has(rowIndex)\">\n            <tr *ngFor=\"let row of group\">\n              <td *ngFor=\"let column of columns\">\n                {{ row | render: column.key }}\n                <!-- TODO allow users to add groupRowsTemplateRef -->\n              </td>\n              <td></td>\n            </tr>\n          </ng-container>\n        </ng-container>\n      </ng-container>\n    </tbody>\n    <tbody\n      *ngIf=\"data && !config.isLoading && config.rowReorder\"\n      class=\"ngx-draggable-row-area\"\n      cdkDropList\n      (cdkDropListDropped)=\"onDrop($event)\"\n    >\n      <ng-container *ngIf=\"!rowTemplate && !config.groupRows\">\n        <ng-container\n          *ngFor=\"\n            let row of data\n              | sort: sortBy\n              | search: term:filteredCountSubject\n              | global: globalSearchTerm:filteredCountSubject\n              | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id }\n          \"\n        >\n          <tr\n            class=\"ngx-draggable-row\"\n            cdkDrag\n            (cdkDragStarted)=\"onDragStart($event)\"\n            [cdkDragStartDelay]=\"config.reorderDelay || 0\"\n            cdkDragLockAxis=\"y\"\n          >\n            <td *ngIf=\"config.checkboxes\">\n              <label class=\"ngx-form-checkbox\">\n                <input\n                  type=\"checkbox\"\n                  id=\"checkbox-draggable-{{ data.indexOf(row) }}\"\n                  [checked]=\"isSelected || selectedCheckboxes.has(data.indexOf(row))\"\n                  (change)=\"onCheckboxSelect($event, row, data.indexOf(row))\"\n                />\n                <em class=\"ngx-form-icon\"></em>\n              </label>\n            </td>\n            <td *ngIf=\"config.radio\">\n              <label>\n                <input\n                  type=\"radio\"\n                  id=\"radio-draggable-{{ data.indexOf(row) }}\"\n                  name=\"radio\"\n                  (change)=\"onRadioSelect($event, row, data.indexOf(row))\"\n                />\n              </label>\n            </td>\n            <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n              <td\n                (click)=\"onClick($event, row, column.key, colIndex, data.indexOf(row))\"\n                (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, data.indexOf(row))\"\n                [class.ngx-table__table-col--selected]=\"\n                  colIndex === selectedCol && !config.selectCell\n                \"\n                [class.ngx-table__table-cell--selected]=\"\n                  colIndex === selectedCol &&\n                  data.indexOf(row) === selectedRow &&\n                  !config.selectCol &&\n                  !config.selectRow\n                \"\n              >\n                <div *ngIf=\"!column.cellTemplate\">{{ row | render: column.key }}</div>\n                <ng-container\n                  *ngIf=\"column.cellTemplate\"\n                  [ngTemplateOutlet]=\"column.cellTemplate\"\n                  [ngTemplateOutletContext]=\"{\n                    $implicit: row,\n                    rowIndex: data.indexOf(row),\n                    column: column\n                  }\"\n                >\n                </ng-container>\n              </td>\n            </ng-container>\n          </tr>\n        </ng-container>\n      </ng-container>\n    </tbody>\n    <tbody *ngIf=\"filterCount === 0\">\n      <tr class=\"ngx-table__body-empty\">\n        <ng-container *ngIf=\"noResultsTemplate\" [ngTemplateOutlet]=\"noResultsTemplate\">\n        </ng-container>\n        <td [attr.colspan]=\"columns && columns.length + 1\" *ngIf=\"!noResultsTemplate\">\n          <div class=\"ngx-table__table-no-results\">No results</div>\n        </td>\n      </tr>\n    </tbody>\n    <tbody *ngIf=\"config.isLoading\">\n      <tr class=\"ngx-table__body-loading\">\n        <ng-container *ngIf=\"loadingTemplate\" [ngTemplateOutlet]=\"loadingTemplate\"> </ng-container>\n        <td [attr.colspan]=\"columns && columns.length + 1\" *ngIf=\"!loadingTemplate\">\n          <div [style.height.px]=\"loadingHeight\" class=\"ngx-table__table-loader-wrapper\">\n            <div class=\"ngx-table__table-loader\"></div>\n          </div>\n        </td>\n      </tr>\n    </tbody>\n    <tfoot *ngIf=\"summaryTemplate\">\n      <tr>\n        <ng-container\n          [ngTemplateOutlet]=\"summaryTemplate\"\n          [ngTemplateOutletContext]=\"{ total: data.length, limit: limit, page: page }\"\n        >\n        </ng-container>\n      </tr>\n    </tfoot>\n  </table>\n  <pagination\n    [attr.id]=\"'pagination' + id\"\n    [id]=\"id\"\n    #paginationComponent\n    [config]=\"config\"\n    [pagination]=\"pagination\"\n    (updateRange)=\"onPagination($event)\"\n  >\n  </pagination>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i3.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i4.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "cdkDropListData", "cdkDropListOrientation", "id", "cdkDropListLockAxis", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListAutoScrollDisabled", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { kind: "directive", type: i4.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragData", "cdkDragLockAxis", "cdkDragRootElement", "cdkDragBoundary", "cdkDragStartDelay", "cdkDragFreeDragPosition", "cdkDragDisabled", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragPreviewContainer"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { kind: "directive", type: i1.CdkFixedSizeVirtualScroll, selector: "cdk-virtual-scroll-viewport[itemSize]", inputs: ["itemSize", "minBufferPx", "maxBufferPx"] }, { kind: "directive", type: i1.CdkVirtualForOf, selector: "[cdkVirtualFor][cdkVirtualForOf]", inputs: ["cdkVirtualForOf", "cdkVirtualForTrackBy", "cdkVirtualForTemplate", "cdkVirtualForTemplateCacheSize"] }, { kind: "component", type: i1.CdkVirtualScrollViewport, selector: "cdk-virtual-scroll-viewport", inputs: ["orientation", "appendOnly"], outputs: ["scrolledIndexChange"] }, { kind: "component", type: i5.PaginationComponent, selector: "pagination", inputs: ["pagination", "config", "id"], outputs: ["updateRange"] }, { kind: "component", type: i6.TableTHeadComponent, selector: "[table-thead]", inputs: ["config", "columns", "sortKey", "sortState", "selectAllTemplate", "filtersTemplate", "additionalActionsTemplate"], outputs: ["filter", "order", "selectAll", "event"] }, { kind: "pipe", type: i7.PaginatePipe, name: "paginate" }, { kind: "pipe", type: i8.SearchPipe, name: "search" }, { kind: "pipe", type: i9.RenderPipe, name: "render" }, { kind: "pipe", type: i10.GlobalSearchPipe, name: "global" }, { kind: "pipe", type: i11.SortPipe, name: "sort" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
export { BaseComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: BaseComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-table', providers: [DefaultConfigService, GroupRowsService, StyleService], changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  class=\"ngx-container\"\n  [class.ngx-container--dark]=\"config.tableLayout.theme === 'dark'\"\n  (dragenter)=\"dragEnter($event)\"\n  (dragover)=\"dragOver($event)\"\n  (dragleave)=\"dragLeave($event)\"\n  (drop)=\"drop($event)\"\n>\n  <table\n    [id]=\"id\"\n    #table\n    [ngClass]=\"tableClass === null || tableClass === '' ? 'ngx-table' : tableClass\"\n    [class.ngx-table__table--tiny]=\"config.tableLayout.style === 'tiny'\"\n    [class.ngx-table__table--normal]=\"config.tableLayout.style === 'normal'\"\n    [class.ngx-table__table--big]=\"config.tableLayout.style === 'big'\"\n    [class.ngx-table__table--borderless]=\"config.tableLayout.borderless\"\n    [class.ngx-table__table--dark]=\"config.tableLayout.theme === 'dark'\"\n    [class.ngx-table__table--hoverable]=\"config.tableLayout.hover\"\n    [class.ngx-table__table--striped]=\"config.tableLayout.striped\"\n    [class.ngx-table__horizontal-scroll]=\"config.horizontalScroll && !config.isLoading\"\n  >\n    <thead\n      [class.ngx-infinite-scroll-viewport-thead]=\"config.infiniteScroll\"\n      table-thead\n      [config]=\"config\"\n      [sortKey]=\"sortKey\"\n      [sortState]=\"sortState\"\n      [selectAllTemplate]=\"selectAllTemplate\"\n      [filtersTemplate]=\"filtersTemplate\"\n      [additionalActionsTemplate]=\"additionalActionsTemplate\"\n      [columns]=\"columns\"\n      (selectAll)=\"onSelectAll()\"\n      (filter)=\"onSearch($event)\"\n      (order)=\"orderBy($event)\"\n      (event)=\"emitEvent($event.event, $event.value)\"\n    ></thead>\n    <tbody *ngIf=\"data && !config.isLoading && !config.rowReorder\">\n      <ng-container *ngIf=\"rowTemplate\">\n        <ul\n          class=\"ngx-table__table-row-context-menu\"\n          [ngStyle]=\"{\n            position: 'absolute',\n            top: rowContextMenuPosition.top,\n            left: rowContextMenuPosition.left\n          }\"\n          *ngIf=\"rowContextMenuPosition.top\"\n        >\n          <ng-container\n            [ngTemplateOutlet]=\"rowContextMenu\"\n            [ngTemplateOutletContext]=\"{ $implicit: rowContextMenuPosition.value }\"\n          >\n          </ng-container>\n        </ul>\n        <ng-container *ngIf=\"!config.infiniteScroll\">\n          <ng-container\n            *ngFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject\n                | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id }\n            \"\n          >\n            <tr\n              (click)=\"onClick($event, row, '', null, data.indexOf(row))\"\n              #contextMenu\n              (contextmenu)=\"onRowContextMenu($event, row, '', null, data.indexOf(row))\"\n              (dblclick)=\"onDoubleClick($event, row, '', null, data.indexOf(row))\"\n              [class.ngx-table__table-row--selected]=\"\n                data.indexOf(row) === selectedRow && !config.selectCell\n              \"\n            >\n              <ng-container\n                [ngTemplateOutlet]=\"rowTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: row, index: data.indexOf(row) }\"\n              >\n              </ng-container>\n              <td *ngIf=\"config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(data.indexOf(row))\n                      ? 'ngx-icon-arrow-down'\n                      : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(data.indexOf(row))\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(data.indexOf(row))) ||\n                config.collapseAllRows\n              \"\n            >\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: data.indexOf(row) }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </ng-container>\n        <cdk-virtual-scroll-viewport\n          itemSize=\"50\"\n          *ngIf=\"config.infiniteScroll\"\n          class=\"ngx-infinite-scroll-viewport\"\n        >\n          <ng-container\n            *cdkVirtualFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject;\n              let rowIndex = index\n            \"\n          >\n            <tr\n              (click)=\"onClick($event, row, '', null, rowIndex)\"\n              #contextMenu\n              (contextmenu)=\"onRowContextMenu($event, row, '', null, rowIndex)\"\n              (dblclick)=\"onDoubleClick($event, row, '', null, rowIndex)\"\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <ng-container\n                [ngTemplateOutlet]=\"rowTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n              >\n              </ng-container>\n              <td *ngIf=\"config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </cdk-virtual-scroll-viewport>\n      </ng-container>\n      <ng-container *ngIf=\"!rowTemplate && !config.groupRows\">\n        <ul\n          class=\"ngx-table__table-row-context-menu\"\n          [ngStyle]=\"{\n            position: 'absolute',\n            top: rowContextMenuPosition.top,\n            left: rowContextMenuPosition.left\n          }\"\n          *ngIf=\"rowContextMenuPosition.top\"\n        >\n          <ng-container\n            [ngTemplateOutlet]=\"rowContextMenu\"\n            [ngTemplateOutletContext]=\"{ $implicit: rowContextMenuPosition.value }\"\n          >\n          </ng-container>\n        </ul>\n        <ng-container *ngIf=\"!config.infiniteScroll\">\n          <ng-container\n            *ngFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject\n                | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id }\n            \"\n          >\n            <tr\n              [class.ngx-table__table-row--selected]=\"\n                data.indexOf(row) === selectedRow && !config.selectCell\n              \"\n            >\n              <td *ngIf=\"config.checkboxes\">\n                <label class=\"ngx-form-checkbox\">\n                  <input\n                    type=\"checkbox\"\n                    id=\"checkbox-{{ data.indexOf(row) }}\"\n                    [checked]=\"isSelected || selectedCheckboxes.has(data.indexOf(row))\"\n                    (change)=\"onCheckboxSelect($event, row, data.indexOf(row))\"\n                  />\n                  <em class=\"ngx-form-icon\"></em>\n                </label>\n              </td>\n              <td *ngIf=\"config.radio\">\n                <label>\n                  <input\n                    type=\"radio\"\n                    id=\"radio-{{ data.indexOf(row) }}\"\n                    name=\"radio\"\n                    (change)=\"onRadioSelect($event, row, data.indexOf(row))\"\n                  />\n                </label>\n              </td>\n              <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n                <td\n                  (click)=\"onClick($event, row, column.key, colIndex, data.indexOf(row))\"\n                  #contextMenu\n                  (contextmenu)=\"\n                    onRowContextMenu($event, row, column.key, colIndex, data.indexOf(row))\n                  \"\n                  (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, data.indexOf(row))\"\n                  [class.pinned-left]=\"column.pinned\"\n                  [ngClass]=\"column.cssClass ? column.cssClass.name : ''\"\n                  [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n                  [class.ngx-table__table-col--selected]=\"\n                    colIndex === selectedCol && !config.selectCell\n                  \"\n                  [class.ngx-table__table-cell--selected]=\"\n                    colIndex === selectedCol &&\n                    data.indexOf(row) === selectedRow &&\n                    !config.selectCol &&\n                    !config.selectRow\n                  \"\n                >\n                  <div *ngIf=\"!column.cellTemplate\">{{ row | render: column.key }}</div>\n                  <ng-container\n                    *ngIf=\"column.cellTemplate\"\n                    [ngTemplateOutlet]=\"column.cellTemplate\"\n                    [ngTemplateOutletContext]=\"{\n                      $implicit: row,\n                      rowIndex: data.indexOf(row),\n                      column: column\n                    }\"\n                  >\n                  </ng-container>\n                </td>\n              </ng-container>\n              <td *ngIf=\"config.additionalActions || config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(data.indexOf(row))\n                      ? 'ngx-icon-arrow-down'\n                      : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(data.indexOf(row))\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(data.indexOf(row))) ||\n                config.collapseAllRows\n              \"\n            >\n              <td *ngIf=\"config.checkboxes || config.radio\"></td>\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: data.indexOf(row) }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </ng-container>\n        <!-- infinite scroll -->\n        <cdk-virtual-scroll-viewport\n          itemSize=\"50\"\n          *ngIf=\"config.infiniteScroll\"\n          class=\"ngx-infinite-scroll-viewport\"\n        >\n          <ng-container\n            *cdkVirtualFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject;\n              let rowIndex = index\n            \"\n          >\n            <tr\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <td *ngIf=\"config.checkboxes\" width=\"3%\">\n                <label class=\"ngx-form-checkbox\">\n                  <input\n                    type=\"checkbox\"\n                    id=\"checkbox-infinite-scroll-{{ rowIndex }}\"\n                    [checked]=\"isSelected || selectedCheckboxes.has(rowIndex)\"\n                    (change)=\"onCheckboxSelect($event, row, rowIndex)\"\n                  />\n                  <em class=\"ngx-form-icon\"></em>\n                </label>\n              </td>\n              <td *ngIf=\"config.radio\" width=\"3%\">\n                <label>\n                  <input\n                    type=\"radio\"\n                    id=\"radio-infinite-scroll-{{ rowIndex }}\"\n                    name=\"radio\"\n                    (change)=\"onRadioSelect($event, row, rowIndex)\"\n                  />\n                </label>\n              </td>\n              <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n                <td\n                  (click)=\"onClick($event, row, column.key, colIndex, rowIndex)\"\n                  #contextMenu\n                  (contextmenu)=\"onRowContextMenu($event, row, column.key, colIndex, rowIndex)\"\n                  (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, rowIndex)\"\n                  [class.pinned-left]=\"column.pinned\"\n                  [ngClass]=\"column.cssClass ? column.cssClass.name : ''\"\n                  [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n                  [class.ngx-table__table-col--selected]=\"\n                    colIndex === selectedCol && !config.selectCell\n                  \"\n                  [class.ngx-table__table-cell--selected]=\"\n                    colIndex === selectedCol &&\n                    rowIndex === selectedRow &&\n                    !config.selectCol &&\n                    !config.selectRow\n                  \"\n                >\n                  <div *ngIf=\"!column.cellTemplate\">{{ row | render: column.key }}</div>\n                  <ng-container\n                    *ngIf=\"column.cellTemplate\"\n                    [ngTemplateOutlet]=\"column.cellTemplate\"\n                    [ngTemplateOutletContext]=\"{\n                      $implicit: row,\n                      rowIndex: rowIndex,\n                      column: column\n                    }\"\n                  >\n                  </ng-container>\n                </td>\n              </ng-container>\n              <td *ngIf=\"config.additionalActions || config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td *ngIf=\"config.checkboxes || config.radio\"></td>\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </cdk-virtual-scroll-viewport>\n      </ng-container>\n      <ng-container *ngIf=\"!rowTemplate && config.groupRows\">\n        <ng-container\n          *ngFor=\"\n            let group of grouped\n              | sort: sortBy:config\n              | search: term:filteredCountSubject:config\n              | global: globalSearchTerm:filteredCountSubject\n              | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n            let rowIndex = index\n          \"\n        >\n          <tr>\n            <ng-container *ngIf=\"!groupRowsHeaderTemplate\">\n              <td [attr.colspan]=\"columns.length\">\n                <div>{{ group[0][groupRowsBy] }} ({{ group.length }})</div>\n              </td>\n            </ng-container>\n            <ng-container\n              *ngIf=\"groupRowsHeaderTemplate\"\n              [ngTemplateOutlet]=\"groupRowsHeaderTemplate\"\n              [ngTemplateOutletContext]=\"{\n                total: group.length,\n                key: groupRowsBy,\n                value: group[0] ? group[0][groupRowsBy] : '',\n                group: group,\n                index: rowIndex\n              }\"\n            >\n            </ng-container>\n            <td>\n              <span\n                class=\"ngx-icon\"\n                *ngIf=\"arrowDefinition\"\n                [ngClass]=\"\n                  isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                \"\n                (click)=\"collapseRow(rowIndex)\"\n              >\n              </span>\n            </td>\n          </tr>\n          <ng-container *ngIf=\"selectedDetailsTemplateRowId.has(rowIndex)\">\n            <tr *ngFor=\"let row of group\">\n              <td *ngFor=\"let column of columns\">\n                {{ row | render: column.key }}\n                <!-- TODO allow users to add groupRowsTemplateRef -->\n              </td>\n              <td></td>\n            </tr>\n          </ng-container>\n        </ng-container>\n      </ng-container>\n    </tbody>\n    <tbody\n      *ngIf=\"data && !config.isLoading && config.rowReorder\"\n      class=\"ngx-draggable-row-area\"\n      cdkDropList\n      (cdkDropListDropped)=\"onDrop($event)\"\n    >\n      <ng-container *ngIf=\"!rowTemplate && !config.groupRows\">\n        <ng-container\n          *ngFor=\"\n            let row of data\n              | sort: sortBy\n              | search: term:filteredCountSubject\n              | global: globalSearchTerm:filteredCountSubject\n              | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id }\n          \"\n        >\n          <tr\n            class=\"ngx-draggable-row\"\n            cdkDrag\n            (cdkDragStarted)=\"onDragStart($event)\"\n            [cdkDragStartDelay]=\"config.reorderDelay || 0\"\n            cdkDragLockAxis=\"y\"\n          >\n            <td *ngIf=\"config.checkboxes\">\n              <label class=\"ngx-form-checkbox\">\n                <input\n                  type=\"checkbox\"\n                  id=\"checkbox-draggable-{{ data.indexOf(row) }}\"\n                  [checked]=\"isSelected || selectedCheckboxes.has(data.indexOf(row))\"\n                  (change)=\"onCheckboxSelect($event, row, data.indexOf(row))\"\n                />\n                <em class=\"ngx-form-icon\"></em>\n              </label>\n            </td>\n            <td *ngIf=\"config.radio\">\n              <label>\n                <input\n                  type=\"radio\"\n                  id=\"radio-draggable-{{ data.indexOf(row) }}\"\n                  name=\"radio\"\n                  (change)=\"onRadioSelect($event, row, data.indexOf(row))\"\n                />\n              </label>\n            </td>\n            <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n              <td\n                (click)=\"onClick($event, row, column.key, colIndex, data.indexOf(row))\"\n                (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, data.indexOf(row))\"\n                [class.ngx-table__table-col--selected]=\"\n                  colIndex === selectedCol && !config.selectCell\n                \"\n                [class.ngx-table__table-cell--selected]=\"\n                  colIndex === selectedCol &&\n                  data.indexOf(row) === selectedRow &&\n                  !config.selectCol &&\n                  !config.selectRow\n                \"\n              >\n                <div *ngIf=\"!column.cellTemplate\">{{ row | render: column.key }}</div>\n                <ng-container\n                  *ngIf=\"column.cellTemplate\"\n                  [ngTemplateOutlet]=\"column.cellTemplate\"\n                  [ngTemplateOutletContext]=\"{\n                    $implicit: row,\n                    rowIndex: data.indexOf(row),\n                    column: column\n                  }\"\n                >\n                </ng-container>\n              </td>\n            </ng-container>\n          </tr>\n        </ng-container>\n      </ng-container>\n    </tbody>\n    <tbody *ngIf=\"filterCount === 0\">\n      <tr class=\"ngx-table__body-empty\">\n        <ng-container *ngIf=\"noResultsTemplate\" [ngTemplateOutlet]=\"noResultsTemplate\">\n        </ng-container>\n        <td [attr.colspan]=\"columns && columns.length + 1\" *ngIf=\"!noResultsTemplate\">\n          <div class=\"ngx-table__table-no-results\">No results</div>\n        </td>\n      </tr>\n    </tbody>\n    <tbody *ngIf=\"config.isLoading\">\n      <tr class=\"ngx-table__body-loading\">\n        <ng-container *ngIf=\"loadingTemplate\" [ngTemplateOutlet]=\"loadingTemplate\"> </ng-container>\n        <td [attr.colspan]=\"columns && columns.length + 1\" *ngIf=\"!loadingTemplate\">\n          <div [style.height.px]=\"loadingHeight\" class=\"ngx-table__table-loader-wrapper\">\n            <div class=\"ngx-table__table-loader\"></div>\n          </div>\n        </td>\n      </tr>\n    </tbody>\n    <tfoot *ngIf=\"summaryTemplate\">\n      <tr>\n        <ng-container\n          [ngTemplateOutlet]=\"summaryTemplate\"\n          [ngTemplateOutletContext]=\"{ total: data.length, limit: limit, page: page }\"\n        >\n        </ng-container>\n      </tr>\n    </tfoot>\n  </table>\n  <pagination\n    [attr.id]=\"'pagination' + id\"\n    [id]=\"id\"\n    #paginationComponent\n    [config]=\"config\"\n    [pagination]=\"pagination\"\n    (updateRange)=\"onPagination($event)\"\n  >\n  </pagination>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.ScrollDispatcher }, { type: i2.StyleService }]; }, propDecorators: { configuration: [{
                type: Input
            }], data: [{
                type: Input
            }], pagination: [{
                type: Input
            }], groupRowsBy: [{
                type: Input
            }], id: [{
                type: Input
            }], toggleRowIndex: [{
                type: Input
            }], detailsTemplate: [{
                type: Input
            }], summaryTemplate: [{
                type: Input
            }], groupRowsHeaderTemplate: [{
                type: Input
            }], filtersTemplate: [{
                type: Input
            }], selectAllTemplate: [{
                type: Input
            }], noResultsTemplate: [{
                type: Input
            }], loadingTemplate: [{
                type: Input
            }], additionalActionsTemplate: [{
                type: Input
            }], rowContextMenu: [{
                type: Input
            }], columns: [{
                type: Input
            }], event: [{
                type: Output
            }], rowTemplate: [{
                type: ContentChild,
                args: [TemplateRef]
            }], paginationComponent: [{
                type: ViewChild,
                args: ['paginationComponent']
            }], contextMenu: [{
                type: ViewChild,
                args: ['contextMenu']
            }], table: [{
                type: ViewChild,
                args: ['table']
            }], viewPort: [{
                type: ViewChild,
                args: [CdkVirtualScrollViewport]
            }], onContextMenuClick: [{
                type: HostListener,
                args: ['document:click', ['$event.target']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtZWFzeS10YWJsZS9zcmMvbGliL2NvbXBvbmVudHMvYmFzZS9iYXNlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1lYXN5LXRhYmxlL3NyYy9saWIvY29tcG9uZW50cy9iYXNlL2Jhc2UuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUE2QixlQUFlLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNwRixPQUFPLEVBRUwsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxZQUFZLEVBQ1osWUFBWSxFQUNaLFlBQVksRUFDWixLQUFLLEVBSUwsTUFBTSxFQUdOLFdBQVcsRUFDWCxTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLEdBQUcsRUFBNEIsS0FBSyxFQUFjLE1BQU0sT0FBTyxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBRXJFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSx3QkFBd0IsRUFBb0IsTUFBTSx3QkFBd0IsQ0FBQztBQUNwRixPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7Ozs7Ozs7OztBQVVqRSxNQU1hLGFBQWE7SUFxRGpCLGtCQUFrQixDQUFDLGFBQWtCO1FBQzFDLElBQUksSUFBSSxDQUFDLFdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxhQUFh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QVosS0FBSztnQkFDRyxVQUFVO3NCQUFsQixLQUFLO2dCQUNHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBQ0csRUFBRTtzQkFBVixLQUFLO2dCQUNHLGNBQWM7c0JBQXRCLEtBQUs7Z0JBQ0csZUFBZTtzQkFBdkIsS0FBSztnQkFDRyxlQUFlO3NCQUF2QixLQUFLO2dCQUNHLHVCQUF1QjtzQkFBL0IsS0FBSztnQkFDRyxlQUFlO3NCQUF2QixLQUFLO2dCQUNHLGlCQUFpQjtzQkFBekIsS0FBSztnQkFDRyxpQkFBaUI7c0JBQXpCLEtBQUs7Z0JBQ0csZUFBZTtzQkFBdkIsS0FBSztnQkFDRyx5QkFBeUI7c0JBQWpDLEtBQUs7Z0JBQ0csY0FBYztzQkFBdEIsS0FBSztnQkFDRyxPQUFPO3NCQUFmLEtBQUs7Z0JBQ2EsS0FBSztzQkFBdkIsTUFBTTtnQkFDMkIsV0FBVztzQkFBNUMsWUFBWTt1QkFBQyxXQUFXO2dCQUNpQixtQkFBbUI7c0JBQTVELFNBQVM7dUJBQUMscUJBQXFCO2dCQUNOLFdBQVc7c0JBQXBDLFNBQVM7dUJBQUMsYUFBYTtnQkFDSixLQUFLO3NCQUF4QixTQUFTO3VCQUFDLE9BQU87Z0JBQ21CLFFBQVE7c0JBQTVDLFNBQVM7dUJBQUMsd0JBQXdCO2dCQUc1QixrQkFBa0I7c0JBRHhCLFlBQVk7dUJBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxlQUFlLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDZGtEcmFnRHJvcCwgQ2RrRHJhZ1N0YXJ0LCBtb3ZlSXRlbUluQXJyYXkgfSBmcm9tICdAYW5ndWxhci9jZGsvZHJhZy1kcm9wJztcbmltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdExpc3RlbmVyLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2UsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q2hpbGQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBUEksIEFwaVR5cGUsIENvbHVtbnMsIENvbmZpZywgRXZlbnQsIFBhZ2luYXRpb24gfSBmcm9tICcuLi8uLic7XG5pbXBvcnQgeyBEZWZhdWx0Q29uZmlnU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbmZpZy1zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2luYXRpb25Db21wb25lbnQsIFBhZ2luYXRpb25SYW5nZSB9IGZyb20gJy4uL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgR3JvdXBSb3dzU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2dyb3VwLXJvd3Muc2VydmljZSc7XG5pbXBvcnQgeyBTdHlsZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9zdHlsZS5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IENka1ZpcnR1YWxTY3JvbGxWaWV3cG9ydCwgU2Nyb2xsRGlzcGF0Y2hlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zY3JvbGxpbmcnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwsIHRocm90dGxlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxudHlwZSBDb2x1bW5LZXlUeXBlID0gc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbjtcblxuaW50ZXJmYWNlIFJvd0NvbnRleHRNZW51UG9zaXRpb24ge1xuICB0b3A6IHN0cmluZyB8IG51bGw7XG4gIGxlZnQ6IHN0cmluZyB8IG51bGw7XG4gIHZhbHVlOiBhbnkgfCBudWxsO1xufVxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduZ3gtdGFibGUnLFxuICBwcm92aWRlcnM6IFtEZWZhdWx0Q29uZmlnU2VydmljZSwgR3JvdXBSb3dzU2VydmljZSwgU3R5bGVTZXJ2aWNlXSxcbiAgdGVtcGxhdGVVcmw6ICcuL2Jhc2UuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHVuc3Vic2NyaWJlID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgcHVibGljIHNlbGVjdGVkUm93OiBudW1iZXI7XG4gIHB1YmxpYyBzZWxlY3RlZENvbDogbnVtYmVyO1xuICBwdWJsaWMgdGVybTogYW55O1xuICBwdWJsaWMgZmlsdGVyQ291bnQgPSAtMTtcbiAgcHVibGljIGZpbHRlcmVkQ291bnRTdWJqZWN0ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICBwdWJsaWMgdGFibGVDbGFzczogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBnbG9iYWxTZWFyY2hUZXJtOiBzdHJpbmc7XG4gIHB1YmxpYyBncm91cGVkOiBhbnkgPSBbXTtcbiAgcHVibGljIGlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgcHVibGljIHBhZ2UgPSAxO1xuICBwdWJsaWMgY291bnQgPSAwO1xuICBwdWJsaWMgc29ydFN0YXRlID0gbmV3IE1hcCgpO1xuICBwdWJsaWMgc29ydEtleTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyByb3dDb250ZXh0TWVudVBvc2l0aW9uOiBSb3dDb250ZXh0TWVudVBvc2l0aW9uID0ge1xuICAgIHRvcDogbnVsbCxcbiAgICBsZWZ0OiBudWxsLFxuICAgIHZhbHVlOiBudWxsLFxuICB9O1xuICBwdWJsaWMgbGltaXQ7XG4gIHB1YmxpYyBzb3J0Qnk6IHsga2V5OiBzdHJpbmcgfSAmIHsgb3JkZXI6IHN0cmluZyB9ID0ge1xuICAgIGtleTogJycsXG4gICAgb3JkZXI6ICdhc2MnLFxuICB9O1xuICBwdWJsaWMgc2VsZWN0ZWREZXRhaWxzVGVtcGxhdGVSb3dJZCA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICBwdWJsaWMgc2VsZWN0ZWRDaGVja2JveGVzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gIHB1YmxpYyBjb25maWc6IENvbmZpZztcblxuICBASW5wdXQoKSBjb25maWd1cmF0aW9uOiBDb25maWc7XG4gIEBJbnB1dCgpIGRhdGE6IGFueVtdO1xuICBASW5wdXQoKSBwYWdpbmF0aW9uOiBQYWdpbmF0aW9uO1xuICBASW5wdXQoKSBncm91cFJvd3NCeTogc3RyaW5nO1xuICBASW5wdXQoKSBpZCA9ICd0YWJsZSc7XG4gIEBJbnB1dCgpIHRvZ2dsZVJvd0luZGV4O1xuICBASW5wdXQoKSBkZXRhaWxzVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gIEBJbnB1dCgpIHN1bW1hcnlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8eyB0b3RhbDogbnVtYmVyOyBsaW1pdDogbnVtYmVyOyBwYWdlOiBudW1iZXIgfT47XG4gIEBJbnB1dCgpIGdyb3VwUm93c0hlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICBASW5wdXQoKSBmaWx0ZXJzVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gIEBJbnB1dCgpIHNlbGVjdEFsbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICBASW5wdXQoKSBub1Jlc3VsdHNUZW1wbGF0ZTogVGVtcGxhdGVSZWY8dm9pZD47XG4gIEBJbnB1dCgpIGxvYWRpbmdUZW1wbGF0ZTogVGVtcGxhdGVSZWY8dm9pZD47XG4gIEBJbnB1dCgpIGFkZGl0aW9uYWxBY3Rpb25zVGVtcGxhdGU6IFRlbXBsYXRlUmVmPHZvaWQ+O1xuICBASW5wdXQoKSByb3dDb250ZXh0TWVudTogVGVtcGxhdGVSZWY8YW55PjtcbiAgQElucHV0KCkgY29sdW1uczogQ29sdW1uc1tdO1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgZXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyPHsgZXZlbnQ6IHN0cmluZzsgdmFsdWU6IGFueSB9PigpO1xuICBAQ29udGVudENoaWxkKFRlbXBsYXRlUmVmKSBwdWJsaWMgcm93VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gIEBWaWV3Q2hpbGQoJ3BhZ2luYXRpb25Db21wb25lbnQnKSBwcml2YXRlIHBhZ2luYXRpb25Db21wb25lbnQ6IFBhZ2luYXRpb25Db21wb25lbnQ7XG4gIEBWaWV3Q2hpbGQoJ2NvbnRleHRNZW51JykgY29udGV4dE1lbnU7XG4gIEBWaWV3Q2hpbGQoJ3RhYmxlJykgdGFibGU7XG4gIEBWaWV3Q2hpbGQoQ2RrVmlydHVhbFNjcm9sbFZpZXdwb3J0KSB2aWV3UG9ydDogQ2RrVmlydHVhbFNjcm9sbFZpZXdwb3J0O1xuXG4gIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQudGFyZ2V0J10pXG4gIHB1YmxpYyBvbkNvbnRleHRNZW51Q2xpY2sodGFyZ2V0RWxlbWVudDogYW55KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29udGV4dE1lbnUgJiYgIXRoaXMuY29udGV4dE1lbnUubmF0aXZlRWxlbWVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSkge1xuICAgICAgdGhpcy5yb3dDb250ZXh0TWVudVBvc2l0aW9uID0ge1xuICAgICAgICB0b3A6IG51bGwsXG4gICAgICAgIGxlZnQ6IG51bGwsXG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzY3JvbGxEaXNwYXRjaGVyOiBTY3JvbGxEaXNwYXRjaGVyLFxuICAgIHB1YmxpYyByZWFkb25seSBzdHlsZVNlcnZpY2U6IFN0eWxlU2VydmljZVxuICApIHtcbiAgICB0aGlzLmZpbHRlcmVkQ291bnRTdWJqZWN0LnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJzY3JpYmUpKS5zdWJzY3JpYmUoKGNvdW50KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5maWx0ZXJDb3VudCA9IGNvdW50O1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jb2x1bW5zKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbY29sdW1uc10gcHJvcGVydHkgcmVxdWlyZWQhJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHRoaXMuY29uZmlnID0gdGhpcy5jb25maWd1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbmZpZyA9IERlZmF1bHRDb25maWdTZXJ2aWNlLmNvbmZpZztcbiAgICB9XG4gICAgdGhpcy5saW1pdCA9IHRoaXMuY29uZmlnLnJvd3M7XG4gICAgaWYgKHRoaXMuZ3JvdXBSb3dzQnkpIHtcbiAgICAgIHRoaXMuZ3JvdXBlZCA9IEdyb3VwUm93c1NlcnZpY2UuZG9Hcm91cFJvd3ModGhpcy5kYXRhLCB0aGlzLmdyb3VwUm93c0J5KTtcbiAgICB9XG4gICAgdGhpcy5kb0RlY29kZVBlcnNpc3RlZFN0YXRlKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnVuc3Vic2NyaWJlLm5leHQoKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlLmNvbXBsZXRlKCk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgY29uc3QgdGhyb3R0bGVWYWx1ZSA9IHRoaXMuY29uZmlnLmluZmluaXRlU2Nyb2xsVGhyb3R0bGVUaW1lXG4gICAgICA/IHRoaXMuY29uZmlnLmluZmluaXRlU2Nyb2xsVGhyb3R0bGVUaW1lXG4gICAgICA6IDIwMDtcbiAgICB0aGlzLnNjcm9sbERpc3BhdGNoZXJcbiAgICAgIC5zY3JvbGxlZCgpXG4gICAgICAucGlwZShcbiAgICAgICAgdGhyb3R0bGVUaW1lKHRocm90dGxlVmFsdWUpLFxuICAgICAgICBmaWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICEhZXZlbnQgJiZcbiAgICAgICAgICAgIHRoaXMudmlld1BvcnQgJiZcbiAgICAgICAgICAgIHRoaXMudmlld1BvcnQuZ2V0UmVuZGVyZWRSYW5nZSgpLmVuZCA9PT0gdGhpcy52aWV3UG9ydC5nZXREYXRhTGVuZ3RoKClcbiAgICAgICAgICApO1xuICAgICAgICB9KSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMudW5zdWJzY3JpYmUpXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoRXZlbnQub25JbmZpbml0ZVNjcm9sbEVuZCwgbnVsbCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBjb25zdCB7IGNvbmZpZ3VyYXRpb24sIGRhdGEsIHBhZ2luYXRpb24sIGdyb3VwUm93c0J5IH0gPSBjaGFuZ2VzO1xuICAgIHRoaXMudG9nZ2xlUm93SW5kZXggPSBjaGFuZ2VzLnRvZ2dsZVJvd0luZGV4O1xuICAgIGlmIChjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uY3VycmVudFZhbHVlKSB7XG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZ3VyYXRpb24uY3VycmVudFZhbHVlO1xuICAgIH1cbiAgICBpZiAoZGF0YSAmJiBkYXRhLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgdGhpcy5kb0FwcGx5RGF0YShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHBhZ2luYXRpb24gJiYgcGFnaW5hdGlvbi5jdXJyZW50VmFsdWUpIHtcbiAgICAgIGNvbnN0IHsgY291bnQsIGxpbWl0LCBvZmZzZXQgfSA9IHBhZ2luYXRpb24uY3VycmVudFZhbHVlIGFzIFBhZ2luYXRpb247XG4gICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICB0aGlzLnBhZ2UgPSBvZmZzZXQ7XG4gICAgfVxuICAgIGlmIChncm91cFJvd3NCeSAmJiBncm91cFJvd3NCeS5jdXJyZW50VmFsdWUpIHtcbiAgICAgIHRoaXMuZ3JvdXBlZCA9IEdyb3VwUm93c1NlcnZpY2UuZG9Hcm91cFJvd3ModGhpcy5kYXRhLCB0aGlzLmdyb3VwUm93c0J5KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudG9nZ2xlUm93SW5kZXggJiYgdGhpcy50b2dnbGVSb3dJbmRleC5jdXJyZW50VmFsdWUpIHtcbiAgICAgIGNvbnN0IHJvdyA9IHRoaXMudG9nZ2xlUm93SW5kZXguY3VycmVudFZhbHVlO1xuICAgICAgdGhpcy5jb2xsYXBzZVJvdyhyb3cuaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIG9yZGVyQnkoY29sdW1uOiBDb2x1bW5zKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiBjb2x1bW4ub3JkZXJFbmFibGVkICE9PSAndW5kZWZpbmVkJyAmJiAhY29sdW1uLm9yZGVyRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNvcnRLZXkgPSBjb2x1bW4ua2V5O1xuICAgIGlmICghdGhpcy5jb25maWcub3JkZXJFbmFibGVkIHx8IHRoaXMuc29ydEtleSA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldENvbHVtbk9yZGVyKGNvbHVtbik7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5vcmRlckV2ZW50T25seSAmJiAhY29sdW1uLm9yZGVyRXZlbnRPbmx5KSB7XG4gICAgICB0aGlzLnNvcnRCeS5rZXkgPSB0aGlzLnNvcnRLZXk7XG4gICAgICB0aGlzLnNvcnRCeS5vcmRlciA9IHRoaXMuc29ydFN0YXRlLmdldCh0aGlzLnNvcnRLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNvcnRCeS5rZXkgPSAnJztcbiAgICAgIHRoaXMuc29ydEJ5Lm9yZGVyID0gJyc7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb25maWcuc2VydmVyUGFnaW5hdGlvbikge1xuICAgICAgdGhpcy5kYXRhID0gWy4uLnRoaXMuZGF0YV07XG4gICAgICB0aGlzLnNvcnRCeSA9IHsgLi4udGhpcy5zb3J0QnkgfTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgIGtleTogdGhpcy5zb3J0S2V5LFxuICAgICAgb3JkZXI6IHRoaXMuc29ydFN0YXRlLmdldCh0aGlzLnNvcnRLZXkpLFxuICAgIH07XG4gICAgdGhpcy5lbWl0RXZlbnQoRXZlbnQub25PcmRlciwgdmFsdWUpO1xuICB9XG5cbiAgb25DbGljaygkZXZlbnQ6IE1vdXNlRXZlbnQsIHJvdzogYW55LCBrZXk6IENvbHVtbktleVR5cGUsIGNvbEluZGV4OiBhbnksIHJvd0luZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb25maWcuc2VsZWN0Um93KSB7XG4gICAgICB0aGlzLnNlbGVjdGVkUm93ID0gcm93SW5kZXg7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5zZWxlY3RDb2wgJiYgYCR7Y29sSW5kZXh9YCkge1xuICAgICAgdGhpcy5zZWxlY3RlZENvbCA9IGNvbEluZGV4O1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcuc2VsZWN0Q2VsbCAmJiBgJHtjb2xJbmRleH1gKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkUm93ID0gcm93SW5kZXg7XG4gICAgICB0aGlzLnNlbGVjdGVkQ29sID0gY29sSW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29uZmlnLmNsaWNrRXZlbnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgICBldmVudDogJGV2ZW50LFxuICAgICAgICByb3csXG4gICAgICAgIGtleSxcbiAgICAgICAgcm93SWQ6IHJvd0luZGV4LFxuICAgICAgICBjb2xJZDogY29sSW5kZXgsXG4gICAgICB9O1xuICAgICAgdGhpcy5lbWl0RXZlbnQoRXZlbnQub25DbGljaywgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIG9uRG91YmxlQ2xpY2soXG4gICAgJGV2ZW50OiBNb3VzZUV2ZW50LFxuICAgIHJvdzogYW55LFxuICAgIGtleTogQ29sdW1uS2V5VHlwZSxcbiAgICBjb2xJbmRleDogYW55LFxuICAgIHJvd0luZGV4OiBudW1iZXJcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgdmFsdWUgPSB7XG4gICAgICBldmVudDogJGV2ZW50LFxuICAgICAgcm93LFxuICAgICAga2V5LFxuICAgICAgcm93SWQ6IHJvd0luZGV4LFxuICAgICAgY29sSWQ6IGNvbEluZGV4LFxuICAgIH07XG4gICAgdGhpcy5lbWl0RXZlbnQoRXZlbnQub25Eb3VibGVDbGljaywgdmFsdWUpO1xuICB9XG5cbiAgb25DaGVja2JveFNlbGVjdCgkZXZlbnQ6IGFueSwgcm93OiBhbnksIHJvd0luZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgIGV2ZW50OiAkZXZlbnQsXG4gICAgICByb3csXG4gICAgICByb3dJZDogcm93SW5kZXgsXG4gICAgfTtcbiAgICB0aGlzLmVtaXRFdmVudChFdmVudC5vbkNoZWNrYm94U2VsZWN0LCB2YWx1ZSk7XG4gIH1cblxuICBvblJhZGlvU2VsZWN0KCRldmVudDogYW55LCByb3c6IGFueSwgcm93SW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgZXZlbnQ6ICRldmVudCxcbiAgICAgIHJvdyxcbiAgICAgIHJvd0lkOiByb3dJbmRleCxcbiAgICB9O1xuICAgIHRoaXMuZW1pdEV2ZW50KEV2ZW50Lm9uUmFkaW9TZWxlY3QsIHZhbHVlKTtcbiAgfVxuXG4gIG9uU2VsZWN0QWxsKCk6IHZvaWQge1xuICAgIHRoaXMuaXNTZWxlY3RlZCA9ICF0aGlzLmlzU2VsZWN0ZWQ7XG4gICAgdGhpcy5lbWl0RXZlbnQoRXZlbnQub25TZWxlY3RBbGwsIHRoaXMuaXNTZWxlY3RlZCk7XG4gIH1cblxuICBvblNlYXJjaCgkZXZlbnQ6IEFycmF5PHsga2V5OiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfT4pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLnNlcnZlclBhZ2luYXRpb24pIHtcbiAgICAgIHRoaXMudGVybSA9ICRldmVudDtcbiAgICB9XG4gICAgdGhpcy5lbWl0RXZlbnQoRXZlbnQub25TZWFyY2gsICRldmVudCk7XG4gIH1cblxuICBvbkdsb2JhbFNlYXJjaCh2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5zZXJ2ZXJQYWdpbmF0aW9uKSB7XG4gICAgICB0aGlzLmdsb2JhbFNlYXJjaFRlcm0gPSB2YWx1ZTtcbiAgICB9XG4gICAgdGhpcy5lbWl0RXZlbnQoRXZlbnQub25HbG9iYWxTZWFyY2gsIHZhbHVlKTtcbiAgfVxuXG4gIG9uUGFnaW5hdGlvbihwYWdpbmF0aW9uOiBQYWdpbmF0aW9uUmFuZ2UpOiB2b2lkIHtcbiAgICB0aGlzLnBhZ2UgPSBwYWdpbmF0aW9uLnBhZ2U7XG4gICAgdGhpcy5saW1pdCA9IHBhZ2luYXRpb24ubGltaXQ7XG4gICAgdGhpcy5jb25maWcucm93cyA9IHBhZ2luYXRpb24ubGltaXQ7XG4gICAgdGhpcy5lbWl0RXZlbnQoRXZlbnQub25QYWdpbmF0aW9uLCBwYWdpbmF0aW9uKTtcbiAgfVxuXG4gIHRvZ2dsZUNoZWNrYm94KHJvd0luZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGVkQ2hlY2tib3hlcy5oYXMocm93SW5kZXgpXG4gICAgICA/IHRoaXMuc2VsZWN0ZWRDaGVja2JveGVzLmRlbGV0ZShyb3dJbmRleClcbiAgICAgIDogdGhpcy5zZWxlY3RlZENoZWNrYm94ZXMuYWRkKHJvd0luZGV4KTtcbiAgfVxuXG4gIGNvbGxhcHNlUm93KHJvd0luZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZERldGFpbHNUZW1wbGF0ZVJvd0lkLmhhcyhyb3dJbmRleCkpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWREZXRhaWxzVGVtcGxhdGVSb3dJZC5kZWxldGUocm93SW5kZXgpO1xuICAgICAgdGhpcy5lbWl0RXZlbnQoRXZlbnQub25Sb3dDb2xsYXBzZWRIaWRlLCByb3dJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWREZXRhaWxzVGVtcGxhdGVSb3dJZC5hZGQocm93SW5kZXgpO1xuICAgICAgdGhpcy5lbWl0RXZlbnQoRXZlbnQub25Sb3dDb2xsYXBzZWRTaG93LCByb3dJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkb0RlY29kZVBlcnNpc3RlZFN0YXRlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jb25maWcucGVyc2lzdFN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhZ2luYXRpb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShFdmVudC5vblBhZ2luYXRpb24pO1xuICAgIGNvbnN0IHNvcnQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShFdmVudC5vbk9yZGVyKTtcbiAgICBjb25zdCBzZWFyY2ggPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShFdmVudC5vblNlYXJjaCk7XG4gICAgaWYgKHBhZ2luYXRpb24pIHtcbiAgICAgIHRoaXMub25QYWdpbmF0aW9uKEpTT04ucGFyc2UocGFnaW5hdGlvbikpO1xuICAgIH1cbiAgICBpZiAoc29ydCkge1xuICAgICAgY29uc3QgeyBrZXksIG9yZGVyIH0gPSBKU09OLnBhcnNlKHNvcnQpO1xuICAgICAgdGhpcy5iaW5kQXBpKHtcbiAgICAgICAgdHlwZTogQVBJLnNvcnRCeSxcbiAgICAgICAgdmFsdWU6IHsgY29sdW1uOiBrZXksIG9yZGVyIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNlYXJjaCkge1xuICAgICAgdGhpcy5iaW5kQXBpKHtcbiAgICAgICAgdHlwZTogQVBJLnNldElucHV0VmFsdWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnBhcnNlKHNlYXJjaCksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpc1Jvd0NvbGxhcHNlZChyb3dJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmNvbGxhcHNlQWxsUm93cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkRGV0YWlsc1RlbXBsYXRlUm93SWQuaGFzKHJvd0luZGV4KTtcbiAgfVxuXG4gIGdldCBsb2FkaW5nSGVpZ2h0KCk6IG51bWJlciB7XG4gICAgY29uc3QgdGFibGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKSBhcyBIVE1MVGFibGVFbGVtZW50O1xuICAgIGlmICh0YWJsZSAmJiB0YWJsZS5yb3dzICYmIHRhYmxlLnJvd3MubGVuZ3RoID4gMykge1xuICAgICAgY29uc3Qgc2VhcmNoRW5hYmxlZCA9IHRoaXMuY29uZmlnLnNlYXJjaEVuYWJsZWQgPyAxIDogMDtcbiAgICAgIGNvbnN0IGhlYWRlckVuYWJsZWQgPSB0aGlzLmNvbmZpZy5oZWFkZXJFbmFibGVkID8gMSA6IDA7XG4gICAgICBjb25zdCBib3JkZXJUckhlaWdodCA9IDE7XG4gICAgICBjb25zdCBib3JkZXJEaXZIZWlnaHQgPSAyO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHRhYmxlLnJvd3MubGVuZ3RoIC0gc2VhcmNoRW5hYmxlZCAtIGhlYWRlckVuYWJsZWQpICpcbiAgICAgICAgICAodGFibGUucm93c1szXS5vZmZzZXRIZWlnaHQgLSBib3JkZXJUckhlaWdodCkgLVxuICAgICAgICBib3JkZXJEaXZIZWlnaHRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDMwO1xuICB9XG5cbiAgZ2V0IGFycm93RGVmaW5pdGlvbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuc2hvd0RldGFpbHNBcnJvdyB8fCB0eXBlb2YgdGhpcy5jb25maWcuc2hvd0RldGFpbHNBcnJvdyA9PT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBvblJvd0NvbnRleHRNZW51KFxuICAgICRldmVudDogTW91c2VFdmVudCxcbiAgICByb3c6IGFueSxcbiAgICBrZXk6IENvbHVtbktleVR5cGUsXG4gICAgY29sSW5kZXg6IGFueSxcbiAgICByb3dJbmRleDogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jb25maWcuc2hvd0NvbnRleHRNZW51KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgZXZlbnQ6ICRldmVudCxcbiAgICAgIHJvdyxcbiAgICAgIGtleSxcbiAgICAgIHJvd0lkOiByb3dJbmRleCxcbiAgICAgIGNvbElkOiBjb2xJbmRleCxcbiAgICB9O1xuICAgIHRoaXMucm93Q29udGV4dE1lbnVQb3NpdGlvbiA9IHtcbiAgICAgIHRvcDogYCR7JGV2ZW50LnBhZ2VZIC0gMTB9cHhgLFxuICAgICAgbGVmdDogYCR7JGV2ZW50LnBhZ2VYIC0gMTB9cHhgLFxuICAgICAgdmFsdWUsXG4gICAgfTtcblxuICAgIHRoaXMuZW1pdEV2ZW50KEV2ZW50Lm9uUm93Q29udGV4dE1lbnUsIHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgZG9BcHBseURhdGEoZGF0YTogU2ltcGxlQ2hhbmdlKTogdm9pZCB7XG4gICAgY29uc3Qgb3JkZXIgPSB0aGlzLmNvbHVtbnMuZmluZCgoYykgPT4gISFjLm9yZGVyQnkpO1xuICAgIGlmIChvcmRlcikge1xuICAgICAgdGhpcy5zb3J0U3RhdGUuc2V0KHRoaXMuc29ydEtleSwgb3JkZXIub3JkZXJCeSA9PT0gJ2FzYycgPyAnZGVzYycgOiAnYXNjJyk7XG4gICAgICB0aGlzLm9yZGVyQnkob3JkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRhdGEgPSBbLi4uZGF0YS5jdXJyZW50VmFsdWVdO1xuICAgIH1cbiAgfVxuXG4gIG9uRHJhZ1N0YXJ0KGV2ZW50OiBDZGtEcmFnU3RhcnQpOiB2b2lkIHtcbiAgICB0aGlzLmVtaXRFdmVudChFdmVudC5vblJlb3JkZXJTdGFydCwgZXZlbnQpO1xuICB9XG5cbiAgb25Ecm9wKGV2ZW50OiBDZGtEcmFnRHJvcDxzdHJpbmdbXT4pOiB2b2lkIHtcbiAgICB0aGlzLmVtaXRFdmVudChFdmVudC5vblJvd0Ryb3AsIGV2ZW50KTtcbiAgICBtb3ZlSXRlbUluQXJyYXkodGhpcy5kYXRhLCBldmVudC5wcmV2aW91c0luZGV4LCBldmVudC5jdXJyZW50SW5kZXgpO1xuICB9XG5cbiAgLy8gRE8gTk9UIFJFTU9WRS4gSXQgaXMgY2FsbGVkIGZyb20gcGFyZW50IGNvbXBvbmVudC4gU2VlIHNyYy9hcHAvZGVtby9hcGktZG9jL2FwaS1kb2MuY29tcG9uZW50LnRzXG4gIGFwaUV2ZW50KGV2ZW50OiBBcGlUeXBlKTogdm9pZCB8IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYmluZEFwaShldmVudCk7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICBwcml2YXRlIGJpbmRBcGkoZXZlbnQ6IEFwaVR5cGUpOiB2b2lkIHwgbnVtYmVyIHtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgQVBJLnJvd0NvbnRleHRNZW51Q2xpY2tlZDpcbiAgICAgICAgdGhpcy5yb3dDb250ZXh0TWVudVBvc2l0aW9uID0ge1xuICAgICAgICAgIHRvcDogbnVsbCxcbiAgICAgICAgICBsZWZ0OiBudWxsLFxuICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQVBJLnRvZ2dsZVJvd0luZGV4OlxuICAgICAgICB0aGlzLmNvbGxhcHNlUm93KGV2ZW50LnZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFQSS50b2dnbGVDaGVja2JveDpcbiAgICAgICAgdGhpcy50b2dnbGVDaGVja2JveChldmVudC52YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBUEkuc2V0SW5wdXRWYWx1ZTpcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNlYXJjaEVuYWJsZWQpIHtcbiAgICAgICAgICBldmVudC52YWx1ZS5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBzZWFyY2hfJHtpbnB1dC5rZXl9YCkgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGBDb2x1bW4gJyR7aW5wdXQua2V5fScgbm90IGF2YWlsYWJsZSBpbiB0aGUgRE9NLiBIYXZlIHlvdSBtaXNzcGVsbGVkIGEgbmFtZT9gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblNlYXJjaChldmVudC52YWx1ZSk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQVBJLm9uR2xvYmFsU2VhcmNoOlxuICAgICAgICB0aGlzLm9uR2xvYmFsU2VhcmNoKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBUEkuc2V0Um93Q2xhc3M6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50LnZhbHVlKSkge1xuICAgICAgICAgIGV2ZW50LnZhbHVlLmZvckVhY2goKHZhbCkgPT4gdGhpcy5zdHlsZVNlcnZpY2Uuc2V0Um93Q2xhc3ModmFsKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHlsZVNlcnZpY2Uuc2V0Um93Q2xhc3MoZXZlbnQudmFsdWUpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFQSS5zZXRDZWxsQ2xhc3M6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50LnZhbHVlKSkge1xuICAgICAgICAgIGV2ZW50LnZhbHVlLmZvckVhY2goKHZhbCkgPT4gdGhpcy5zdHlsZVNlcnZpY2Uuc2V0Q2VsbENsYXNzKHZhbCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3R5bGVTZXJ2aWNlLnNldENlbGxDbGFzcyhldmVudC52YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBUEkuc2V0Um93U3R5bGU6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50LnZhbHVlKSkge1xuICAgICAgICAgIGV2ZW50LnZhbHVlLmZvckVhY2goKHZhbCkgPT4gdGhpcy5zdHlsZVNlcnZpY2Uuc2V0Um93U3R5bGUodmFsKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHlsZVNlcnZpY2Uuc2V0Um93U3R5bGUoZXZlbnQudmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQVBJLnNldENlbGxTdHlsZTpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQudmFsdWUpKSB7XG4gICAgICAgICAgZXZlbnQudmFsdWUuZm9yRWFjaCgodmFsKSA9PiB0aGlzLnN0eWxlU2VydmljZS5zZXRDZWxsU3R5bGUodmFsKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHlsZVNlcnZpY2Uuc2V0Q2VsbFN0eWxlKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFQSS5zZXRUYWJsZUNsYXNzOlxuICAgICAgICB0aGlzLnRhYmxlQ2xhc3MgPSBldmVudC52YWx1ZTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBUEkuZ2V0UGFnaW5hdGlvblRvdGFsSXRlbXM6XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2luYXRpb25Db21wb25lbnQucGFnaW5hdGlvbkRpcmVjdGl2ZS5nZXRUb3RhbEl0ZW1zKCk7XG4gICAgICBjYXNlIEFQSS5nZXRQYWdpbmF0aW9uQ3VycmVudFBhZ2U6XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2luYXRpb25Db21wb25lbnQucGFnaW5hdGlvbkRpcmVjdGl2ZS5nZXRDdXJyZW50KCk7XG4gICAgICBjYXNlIEFQSS5nZXRQYWdpbmF0aW9uTGFzdFBhZ2U6XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2luYXRpb25Db21wb25lbnQucGFnaW5hdGlvbkRpcmVjdGl2ZS5nZXRMYXN0UGFnZSgpO1xuICAgICAgY2FzZSBBUEkuZ2V0TnVtYmVyT2ZSb3dzUGVyUGFnZTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnaW5hdGlvbkNvbXBvbmVudC5wYWdpbmF0aW9uRGlyZWN0aXZlLmlzTGFzdFBhZ2UoKVxuICAgICAgICAgID8gdGhpcy5wYWdpbmF0aW9uQ29tcG9uZW50LnBhZ2luYXRpb25EaXJlY3RpdmUuZ2V0VG90YWxJdGVtcygpICUgdGhpcy5saW1pdFxuICAgICAgICAgIDogdGhpcy5saW1pdDtcbiAgICAgIGNhc2UgQVBJLnNldFBhZ2luYXRpb25DdXJyZW50UGFnZTpcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uQ29tcG9uZW50LnBhZ2luYXRpb25EaXJlY3RpdmUuc2V0Q3VycmVudChldmVudC52YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBUEkuc2V0UGFnaW5hdGlvblJhbmdlOlxuICAgICAgICB0aGlzLnBhZ2luYXRpb25Db21wb25lbnQucmFuZ2VzID0gZXZlbnQudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBUEkuc2V0UGFnaW5hdGlvblByZXZpb3VzTGFiZWw6XG4gICAgICAgIHRoaXMucGFnaW5hdGlvbkNvbXBvbmVudC5wcmV2aW91c0xhYmVsID0gZXZlbnQudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBUEkuc2V0UGFnaW5hdGlvbk5leHRMYWJlbDpcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uQ29tcG9uZW50Lm5leHRMYWJlbCA9IGV2ZW50LnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQVBJLnNldFBhZ2luYXRpb25EaXNwbGF5TGltaXQ6XG4gICAgICAgIHRoaXMucGFnaW5hdGlvbkNvbXBvbmVudC5jaGFuZ2VMaW1pdChldmVudC52YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBUEkuc29ydEJ5OlxuICAgICAgICBjb25zdCBjb2x1bW46IENvbHVtbnMgPSB7IHRpdGxlOiAnJywga2V5OiBldmVudC52YWx1ZS5jb2x1bW4sIG9yZGVyQnk6IGV2ZW50LnZhbHVlLm9yZGVyIH07XG4gICAgICAgIHRoaXMub3JkZXJCeShjb2x1bW4pO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRDb2x1bW5PcmRlcihjb2x1bW46IENvbHVtbnMpOiB2b2lkIHtcbiAgICBjb25zdCBrZXk6IHN0cmluZyA9IGNvbHVtbi5rZXk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuc29ydFN0YXRlLmdldChrZXkpKSB7XG4gICAgICBjYXNlICcnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHRoaXMuc29ydFN0YXRlLnNldChrZXksIGNvbHVtbi5vcmRlckJ5IHx8ICdkZXNjJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXNjJzpcbiAgICAgICAgdGhpcy5jb25maWcudGhyZWVXYXlTb3J0ID8gdGhpcy5zb3J0U3RhdGUuc2V0KGtleSwgJycpIDogdGhpcy5zb3J0U3RhdGUuc2V0KGtleSwgJ2Rlc2MnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkZXNjJzpcbiAgICAgICAgdGhpcy5zb3J0U3RhdGUuc2V0KGtleSwgJ2FzYycpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuc29ydFN0YXRlLnNpemUgPiAxKSB7XG4gICAgICBjb25zdCB0ZW1wID0gdGhpcy5zb3J0U3RhdGUuZ2V0KGtleSk7XG4gICAgICB0aGlzLnNvcnRTdGF0ZS5jbGVhcigpO1xuICAgICAgdGhpcy5zb3J0U3RhdGUuc2V0KGtleSwgdGVtcCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGVtaXRFdmVudChldmVudDogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5ldmVudC5lbWl0KHsgZXZlbnQsIHZhbHVlIH0pO1xuICAgIGlmICh0aGlzLmNvbmZpZy5wZXJzaXN0U3RhdGUpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGV2ZW50LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcubG9nZ2VyKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2coeyBldmVudCwgdmFsdWUgfSk7XG4gICAgfVxuICB9XG5cbiAgZHJhZ0VudGVyKCRldmVudDogRHJhZ0V2ZW50KTogdm9pZCB7XG4gICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZHJhZ092ZXIoJGV2ZW50OiBEcmFnRXZlbnQpOiB2b2lkIHtcbiAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBkcmFnTGVhdmUoJGV2ZW50OiBEcmFnRXZlbnQpOiB2b2lkIHtcbiAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBkcm9wKCRldmVudDogRHJhZ0V2ZW50KTogdm9pZCB7XG4gICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IGZpbGUgPSAkZXZlbnQuZGF0YVRyYW5zZmVyPy5maWxlcz8uWzBdO1xuICAgIGlmIChmaWxlPy50eXBlICE9PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZygnRmlsZSBub3QgYWxsb3dlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IChldmVudCkgPT4ge1xuICAgICAgdGhpcy5kYXRhID0gSlNPTi5wYXJzZShldmVudD8udGFyZ2V0Py5yZXN1bHQgYXMgc3RyaW5nKTtcbiAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG4gICAgZmlsZVJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICB9XG59XG4iLCI8ZGl2XG4gIGNsYXNzPVwibmd4LWNvbnRhaW5lclwiXG4gIFtjbGFzcy5uZ3gtY29udGFpbmVyLS1kYXJrXT1cImNvbmZpZy50YWJsZUxheW91dC50aGVtZSA9PT0gJ2RhcmsnXCJcbiAgKGRyYWdlbnRlcik9XCJkcmFnRW50ZXIoJGV2ZW50KVwiXG4gIChkcmFnb3Zlcik9XCJkcmFnT3ZlcigkZXZlbnQpXCJcbiAgKGRyYWdsZWF2ZSk9XCJkcmFnTGVhdmUoJGV2ZW50KVwiXG4gIChkcm9wKT1cImRyb3AoJGV2ZW50KVwiXG4+XG4gIDx0YWJsZVxuICAgIFtpZF09XCJpZFwiXG4gICAgI3RhYmxlXG4gICAgW25nQ2xhc3NdPVwidGFibGVDbGFzcyA9PT0gbnVsbCB8fCB0YWJsZUNsYXNzID09PSAnJyA/ICduZ3gtdGFibGUnIDogdGFibGVDbGFzc1wiXG4gICAgW2NsYXNzLm5neC10YWJsZV9fdGFibGUtLXRpbnldPVwiY29uZmlnLnRhYmxlTGF5b3V0LnN0eWxlID09PSAndGlueSdcIlxuICAgIFtjbGFzcy5uZ3gtdGFibGVfX3RhYmxlLS1ub3JtYWxdPVwiY29uZmlnLnRhYmxlTGF5b3V0LnN0eWxlID09PSAnbm9ybWFsJ1wiXG4gICAgW2NsYXNzLm5neC10YWJsZV9fdGFibGUtLWJpZ109XCJjb25maWcudGFibGVMYXlvdXQuc3R5bGUgPT09ICdiaWcnXCJcbiAgICBbY2xhc3Mubmd4LXRhYmxlX190YWJsZS0tYm9yZGVybGVzc109XCJjb25maWcudGFibGVMYXlvdXQuYm9yZGVybGVzc1wiXG4gICAgW2NsYXNzLm5neC10YWJsZV9fdGFibGUtLWRhcmtdPVwiY29uZmlnLnRhYmxlTGF5b3V0LnRoZW1lID09PSAnZGFyaydcIlxuICAgIFtjbGFzcy5uZ3gtdGFibGVfX3RhYmxlLS1ob3ZlcmFibGVdPVwiY29uZmlnLnRhYmxlTGF5b3V0LmhvdmVyXCJcbiAgICBbY2xhc3Mubmd4LXRhYmxlX190YWJsZS0tc3RyaXBlZF09XCJjb25maWcudGFibGVMYXlvdXQuc3RyaXBlZFwiXG4gICAgW2NsYXNzLm5neC10YWJsZV9faG9yaXpvbnRhbC1zY3JvbGxdPVwiY29uZmlnLmhvcml6b250YWxTY3JvbGwgJiYgIWNvbmZpZy5pc0xvYWRpbmdcIlxuICA+XG4gICAgPHRoZWFkXG4gICAgICBbY2xhc3Mubmd4LWluZmluaXRlLXNjcm9sbC12aWV3cG9ydC10aGVhZF09XCJjb25maWcuaW5maW5pdGVTY3JvbGxcIlxuICAgICAgdGFibGUtdGhlYWRcbiAgICAgIFtjb25maWddPVwiY29uZmlnXCJcbiAgICAgIFtzb3J0S2V5XT1cInNvcnRLZXlcIlxuICAgICAgW3NvcnRTdGF0ZV09XCJzb3J0U3RhdGVcIlxuICAgICAgW3NlbGVjdEFsbFRlbXBsYXRlXT1cInNlbGVjdEFsbFRlbXBsYXRlXCJcbiAgICAgIFtmaWx0ZXJzVGVtcGxhdGVdPVwiZmlsdGVyc1RlbXBsYXRlXCJcbiAgICAgIFthZGRpdGlvbmFsQWN0aW9uc1RlbXBsYXRlXT1cImFkZGl0aW9uYWxBY3Rpb25zVGVtcGxhdGVcIlxuICAgICAgW2NvbHVtbnNdPVwiY29sdW1uc1wiXG4gICAgICAoc2VsZWN0QWxsKT1cIm9uU2VsZWN0QWxsKClcIlxuICAgICAgKGZpbHRlcik9XCJvblNlYXJjaCgkZXZlbnQpXCJcbiAgICAgIChvcmRlcik9XCJvcmRlckJ5KCRldmVudClcIlxuICAgICAgKGV2ZW50KT1cImVtaXRFdmVudCgkZXZlbnQuZXZlbnQsICRldmVudC52YWx1ZSlcIlxuICAgID48L3RoZWFkPlxuICAgIDx0Ym9keSAqbmdJZj1cImRhdGEgJiYgIWNvbmZpZy5pc0xvYWRpbmcgJiYgIWNvbmZpZy5yb3dSZW9yZGVyXCI+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwicm93VGVtcGxhdGVcIj5cbiAgICAgICAgPHVsXG4gICAgICAgICAgY2xhc3M9XCJuZ3gtdGFibGVfX3RhYmxlLXJvdy1jb250ZXh0LW1lbnVcIlxuICAgICAgICAgIFtuZ1N0eWxlXT1cIntcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiByb3dDb250ZXh0TWVudVBvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHJvd0NvbnRleHRNZW51UG9zaXRpb24ubGVmdFxuICAgICAgICAgIH1cIlxuICAgICAgICAgICpuZ0lmPVwicm93Q29udGV4dE1lbnVQb3NpdGlvbi50b3BcIlxuICAgICAgICA+XG4gICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwicm93Q29udGV4dE1lbnVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgJGltcGxpY2l0OiByb3dDb250ZXh0TWVudVBvc2l0aW9uLnZhbHVlIH1cIlxuICAgICAgICAgID5cbiAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC91bD5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFjb25maWcuaW5maW5pdGVTY3JvbGxcIj5cbiAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAqbmdGb3I9XCJcbiAgICAgICAgICAgICAgbGV0IHJvdyBvZiBkYXRhXG4gICAgICAgICAgICAgICAgfCBzb3J0OiBzb3J0QnlcbiAgICAgICAgICAgICAgICB8IHNlYXJjaDogdGVybTpmaWx0ZXJlZENvdW50U3ViamVjdFxuICAgICAgICAgICAgICAgIHwgZ2xvYmFsOiBnbG9iYWxTZWFyY2hUZXJtOmZpbHRlcmVkQ291bnRTdWJqZWN0XG4gICAgICAgICAgICAgICAgfCBwYWdpbmF0ZTogeyBpdGVtc1BlclBhZ2U6IGxpbWl0LCBjdXJyZW50UGFnZTogcGFnZSwgdG90YWxJdGVtczogY291bnQsIGlkOiBpZCB9XG4gICAgICAgICAgICBcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDx0clxuICAgICAgICAgICAgICAoY2xpY2spPVwib25DbGljaygkZXZlbnQsIHJvdywgJycsIG51bGwsIGRhdGEuaW5kZXhPZihyb3cpKVwiXG4gICAgICAgICAgICAgICNjb250ZXh0TWVudVxuICAgICAgICAgICAgICAoY29udGV4dG1lbnUpPVwib25Sb3dDb250ZXh0TWVudSgkZXZlbnQsIHJvdywgJycsIG51bGwsIGRhdGEuaW5kZXhPZihyb3cpKVwiXG4gICAgICAgICAgICAgIChkYmxjbGljayk9XCJvbkRvdWJsZUNsaWNrKCRldmVudCwgcm93LCAnJywgbnVsbCwgZGF0YS5pbmRleE9mKHJvdykpXCJcbiAgICAgICAgICAgICAgW2NsYXNzLm5neC10YWJsZV9fdGFibGUtcm93LS1zZWxlY3RlZF09XCJcbiAgICAgICAgICAgICAgICBkYXRhLmluZGV4T2Yocm93KSA9PT0gc2VsZWN0ZWRSb3cgJiYgIWNvbmZpZy5zZWxlY3RDZWxsXG4gICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJyb3dUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgJGltcGxpY2l0OiByb3csIGluZGV4OiBkYXRhLmluZGV4T2Yocm93KSB9XCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgPHRkICpuZ0lmPVwiY29uZmlnLmRldGFpbHNUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cIm5neC1pY29uXCJcbiAgICAgICAgICAgICAgICAgICpuZ0lmPVwiYXJyb3dEZWZpbml0aW9uXCJcbiAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIlxuICAgICAgICAgICAgICAgICAgICBpc1Jvd0NvbGxhcHNlZChkYXRhLmluZGV4T2Yocm93KSlcbiAgICAgICAgICAgICAgICAgICAgICA/ICduZ3gtaWNvbi1hcnJvdy1kb3duJ1xuICAgICAgICAgICAgICAgICAgICAgIDogJ25neC1pY29uLWFycm93LXJpZ2h0J1xuICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgIChjbGljayk9XCJjb2xsYXBzZVJvdyhkYXRhLmluZGV4T2Yocm93KSlcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgPHRyXG4gICAgICAgICAgICAgICpuZ0lmPVwiXG4gICAgICAgICAgICAgICAgKGNvbmZpZy5kZXRhaWxzVGVtcGxhdGUgJiYgc2VsZWN0ZWREZXRhaWxzVGVtcGxhdGVSb3dJZC5oYXMoZGF0YS5pbmRleE9mKHJvdykpKSB8fFxuICAgICAgICAgICAgICAgIGNvbmZpZy5jb2xsYXBzZUFsbFJvd3NcbiAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHRkIFthdHRyLmNvbHNwYW5dPVwiY29sdW1ucy5sZW5ndGggKyAxXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwiZGV0YWlsc1RlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7ICRpbXBsaWNpdDogcm93LCBpbmRleDogZGF0YS5pbmRleE9mKHJvdykgfVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxjZGstdmlydHVhbC1zY3JvbGwtdmlld3BvcnRcbiAgICAgICAgICBpdGVtU2l6ZT1cIjUwXCJcbiAgICAgICAgICAqbmdJZj1cImNvbmZpZy5pbmZpbml0ZVNjcm9sbFwiXG4gICAgICAgICAgY2xhc3M9XCJuZ3gtaW5maW5pdGUtc2Nyb2xsLXZpZXdwb3J0XCJcbiAgICAgICAgPlxuICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICpjZGtWaXJ0dWFsRm9yPVwiXG4gICAgICAgICAgICAgIGxldCByb3cgb2YgZGF0YVxuICAgICAgICAgICAgICAgIHwgc29ydDogc29ydEJ5XG4gICAgICAgICAgICAgICAgfCBzZWFyY2g6IHRlcm06ZmlsdGVyZWRDb3VudFN1YmplY3RcbiAgICAgICAgICAgICAgICB8IGdsb2JhbDogZ2xvYmFsU2VhcmNoVGVybTpmaWx0ZXJlZENvdW50U3ViamVjdDtcbiAgICAgICAgICAgICAgbGV0IHJvd0luZGV4ID0gaW5kZXhcbiAgICAgICAgICAgIFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHRyXG4gICAgICAgICAgICAgIChjbGljayk9XCJvbkNsaWNrKCRldmVudCwgcm93LCAnJywgbnVsbCwgcm93SW5kZXgpXCJcbiAgICAgICAgICAgICAgI2NvbnRleHRNZW51XG4gICAgICAgICAgICAgIChjb250ZXh0bWVudSk9XCJvblJvd0NvbnRleHRNZW51KCRldmVudCwgcm93LCAnJywgbnVsbCwgcm93SW5kZXgpXCJcbiAgICAgICAgICAgICAgKGRibGNsaWNrKT1cIm9uRG91YmxlQ2xpY2soJGV2ZW50LCByb3csICcnLCBudWxsLCByb3dJbmRleClcIlxuICAgICAgICAgICAgICBbY2xhc3Mubmd4LXRhYmxlX190YWJsZS1yb3ctLXNlbGVjdGVkXT1cIlxuICAgICAgICAgICAgICAgIHJvd0luZGV4ID09PSBzZWxlY3RlZFJvdyAmJiAhY29uZmlnLnNlbGVjdENlbGxcbiAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInJvd1RlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyAkaW1wbGljaXQ6IHJvdywgaW5kZXg6IHJvd0luZGV4IH1cIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJjb25maWcuZGV0YWlsc1RlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwibmd4LWljb25cIlxuICAgICAgICAgICAgICAgICAgKm5nSWY9XCJhcnJvd0RlZmluaXRpb25cIlxuICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiXG4gICAgICAgICAgICAgICAgICAgIGlzUm93Q29sbGFwc2VkKHJvd0luZGV4KSA/ICduZ3gtaWNvbi1hcnJvdy1kb3duJyA6ICduZ3gtaWNvbi1hcnJvdy1yaWdodCdcbiAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAoY2xpY2spPVwiY29sbGFwc2VSb3cocm93SW5kZXgpXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgIDx0clxuICAgICAgICAgICAgICAqbmdJZj1cIlxuICAgICAgICAgICAgICAgIChjb25maWcuZGV0YWlsc1RlbXBsYXRlICYmIHNlbGVjdGVkRGV0YWlsc1RlbXBsYXRlUm93SWQuaGFzKHJvd0luZGV4KSkgfHxcbiAgICAgICAgICAgICAgICBjb25maWcuY29sbGFwc2VBbGxSb3dzXG4gICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDx0ZCBbYXR0ci5jb2xzcGFuXT1cImNvbHVtbnMubGVuZ3RoICsgMVwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImRldGFpbHNUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyAkaW1wbGljaXQ6IHJvdywgaW5kZXg6IHJvd0luZGV4IH1cIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvY2RrLXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0PlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXJvd1RlbXBsYXRlICYmICFjb25maWcuZ3JvdXBSb3dzXCI+XG4gICAgICAgIDx1bFxuICAgICAgICAgIGNsYXNzPVwibmd4LXRhYmxlX190YWJsZS1yb3ctY29udGV4dC1tZW51XCJcbiAgICAgICAgICBbbmdTdHlsZV09XCJ7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogcm93Q29udGV4dE1lbnVQb3NpdGlvbi50b3AsXG4gICAgICAgICAgICBsZWZ0OiByb3dDb250ZXh0TWVudVBvc2l0aW9uLmxlZnRcbiAgICAgICAgICB9XCJcbiAgICAgICAgICAqbmdJZj1cInJvd0NvbnRleHRNZW51UG9zaXRpb24udG9wXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInJvd0NvbnRleHRNZW51XCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7ICRpbXBsaWNpdDogcm93Q29udGV4dE1lbnVQb3NpdGlvbi52YWx1ZSB9XCJcbiAgICAgICAgICA+XG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvdWw+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhY29uZmlnLmluZmluaXRlU2Nyb2xsXCI+XG4gICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgKm5nRm9yPVwiXG4gICAgICAgICAgICAgIGxldCByb3cgb2YgZGF0YVxuICAgICAgICAgICAgICAgIHwgc29ydDogc29ydEJ5XG4gICAgICAgICAgICAgICAgfCBzZWFyY2g6IHRlcm06ZmlsdGVyZWRDb3VudFN1YmplY3RcbiAgICAgICAgICAgICAgICB8IGdsb2JhbDogZ2xvYmFsU2VhcmNoVGVybTpmaWx0ZXJlZENvdW50U3ViamVjdFxuICAgICAgICAgICAgICAgIHwgcGFnaW5hdGU6IHsgaXRlbXNQZXJQYWdlOiBsaW1pdCwgY3VycmVudFBhZ2U6IHBhZ2UsIHRvdGFsSXRlbXM6IGNvdW50LCBpZDogaWQgfVxuICAgICAgICAgICAgXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8dHJcbiAgICAgICAgICAgICAgW2NsYXNzLm5neC10YWJsZV9fdGFibGUtcm93LS1zZWxlY3RlZF09XCJcbiAgICAgICAgICAgICAgICBkYXRhLmluZGV4T2Yocm93KSA9PT0gc2VsZWN0ZWRSb3cgJiYgIWNvbmZpZy5zZWxlY3RDZWxsXG4gICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDx0ZCAqbmdJZj1cImNvbmZpZy5jaGVja2JveGVzXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwibmd4LWZvcm0tY2hlY2tib3hcIj5cbiAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICBpZD1cImNoZWNrYm94LXt7IGRhdGEuaW5kZXhPZihyb3cpIH19XCJcbiAgICAgICAgICAgICAgICAgICAgW2NoZWNrZWRdPVwiaXNTZWxlY3RlZCB8fCBzZWxlY3RlZENoZWNrYm94ZXMuaGFzKGRhdGEuaW5kZXhPZihyb3cpKVwiXG4gICAgICAgICAgICAgICAgICAgIChjaGFuZ2UpPVwib25DaGVja2JveFNlbGVjdCgkZXZlbnQsIHJvdywgZGF0YS5pbmRleE9mKHJvdykpXCJcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8ZW0gY2xhc3M9XCJuZ3gtZm9ybS1pY29uXCI+PC9lbT5cbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJjb25maWcucmFkaW9cIj5cbiAgICAgICAgICAgICAgICA8bGFiZWw+XG4gICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgICAgICAgICAgaWQ9XCJyYWRpby17eyBkYXRhLmluZGV4T2Yocm93KSB9fVwiXG4gICAgICAgICAgICAgICAgICAgIG5hbWU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgICAgIChjaGFuZ2UpPVwib25SYWRpb1NlbGVjdCgkZXZlbnQsIHJvdywgZGF0YS5pbmRleE9mKHJvdykpXCJcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGNvbHVtbnM7IGxldCBjb2xJbmRleCA9IGluZGV4XCI+XG4gICAgICAgICAgICAgICAgPHRkXG4gICAgICAgICAgICAgICAgICAoY2xpY2spPVwib25DbGljaygkZXZlbnQsIHJvdywgY29sdW1uLmtleSwgY29sSW5kZXgsIGRhdGEuaW5kZXhPZihyb3cpKVwiXG4gICAgICAgICAgICAgICAgICAjY29udGV4dE1lbnVcbiAgICAgICAgICAgICAgICAgIChjb250ZXh0bWVudSk9XCJcbiAgICAgICAgICAgICAgICAgICAgb25Sb3dDb250ZXh0TWVudSgkZXZlbnQsIHJvdywgY29sdW1uLmtleSwgY29sSW5kZXgsIGRhdGEuaW5kZXhPZihyb3cpKVxuICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgIChkYmxjbGljayk9XCJvbkRvdWJsZUNsaWNrKCRldmVudCwgcm93LCBjb2x1bW4ua2V5LCBjb2xJbmRleCwgZGF0YS5pbmRleE9mKHJvdykpXCJcbiAgICAgICAgICAgICAgICAgIFtjbGFzcy5waW5uZWQtbGVmdF09XCJjb2x1bW4ucGlubmVkXCJcbiAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cImNvbHVtbi5jc3NDbGFzcyA/IGNvbHVtbi5jc3NDbGFzcy5uYW1lIDogJydcIlxuICAgICAgICAgICAgICAgICAgW3N0eWxlLmxlZnRdPVwic3R5bGVTZXJ2aWNlLnBpbm5lZFdpZHRoKGNvbHVtbi5waW5uZWQsIGNvbEluZGV4KVwiXG4gICAgICAgICAgICAgICAgICBbY2xhc3Mubmd4LXRhYmxlX190YWJsZS1jb2wtLXNlbGVjdGVkXT1cIlxuICAgICAgICAgICAgICAgICAgICBjb2xJbmRleCA9PT0gc2VsZWN0ZWRDb2wgJiYgIWNvbmZpZy5zZWxlY3RDZWxsXG4gICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgW2NsYXNzLm5neC10YWJsZV9fdGFibGUtY2VsbC0tc2VsZWN0ZWRdPVwiXG4gICAgICAgICAgICAgICAgICAgIGNvbEluZGV4ID09PSBzZWxlY3RlZENvbCAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRhLmluZGV4T2Yocm93KSA9PT0gc2VsZWN0ZWRSb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgIWNvbmZpZy5zZWxlY3RDb2wgJiZcbiAgICAgICAgICAgICAgICAgICAgIWNvbmZpZy5zZWxlY3RSb3dcbiAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cIiFjb2x1bW4uY2VsbFRlbXBsYXRlXCI+e3sgcm93IHwgcmVuZGVyOiBjb2x1bW4ua2V5IH19PC9kaXY+XG4gICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiY29sdW1uLmNlbGxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbHVtbi5jZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICRpbXBsaWNpdDogcm93LFxuICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4OiBkYXRhLmluZGV4T2Yocm93KSxcbiAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJjb25maWcuYWRkaXRpb25hbEFjdGlvbnMgfHwgY29uZmlnLmRldGFpbHNUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cIm5neC1pY29uXCJcbiAgICAgICAgICAgICAgICAgICpuZ0lmPVwiYXJyb3dEZWZpbml0aW9uXCJcbiAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIlxuICAgICAgICAgICAgICAgICAgICBpc1Jvd0NvbGxhcHNlZChkYXRhLmluZGV4T2Yocm93KSlcbiAgICAgICAgICAgICAgICAgICAgICA/ICduZ3gtaWNvbi1hcnJvdy1kb3duJ1xuICAgICAgICAgICAgICAgICAgICAgIDogJ25neC1pY29uLWFycm93LXJpZ2h0J1xuICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgIChjbGljayk9XCJjb2xsYXBzZVJvdyhkYXRhLmluZGV4T2Yocm93KSlcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgPHRyXG4gICAgICAgICAgICAgICpuZ0lmPVwiXG4gICAgICAgICAgICAgICAgKGNvbmZpZy5kZXRhaWxzVGVtcGxhdGUgJiYgc2VsZWN0ZWREZXRhaWxzVGVtcGxhdGVSb3dJZC5oYXMoZGF0YS5pbmRleE9mKHJvdykpKSB8fFxuICAgICAgICAgICAgICAgIGNvbmZpZy5jb2xsYXBzZUFsbFJvd3NcbiAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHRkICpuZ0lmPVwiY29uZmlnLmNoZWNrYm94ZXMgfHwgY29uZmlnLnJhZGlvXCI+PC90ZD5cbiAgICAgICAgICAgICAgPHRkIFthdHRyLmNvbHNwYW5dPVwiY29sdW1ucy5sZW5ndGggKyAxXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwiZGV0YWlsc1RlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7ICRpbXBsaWNpdDogcm93LCBpbmRleDogZGF0YS5pbmRleE9mKHJvdykgfVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwhLS0gaW5maW5pdGUgc2Nyb2xsIC0tPlxuICAgICAgICA8Y2RrLXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0XG4gICAgICAgICAgaXRlbVNpemU9XCI1MFwiXG4gICAgICAgICAgKm5nSWY9XCJjb25maWcuaW5maW5pdGVTY3JvbGxcIlxuICAgICAgICAgIGNsYXNzPVwibmd4LWluZmluaXRlLXNjcm9sbC12aWV3cG9ydFwiXG4gICAgICAgID5cbiAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAqY2RrVmlydHVhbEZvcj1cIlxuICAgICAgICAgICAgICBsZXQgcm93IG9mIGRhdGFcbiAgICAgICAgICAgICAgICB8IHNvcnQ6IHNvcnRCeVxuICAgICAgICAgICAgICAgIHwgc2VhcmNoOiB0ZXJtOmZpbHRlcmVkQ291bnRTdWJqZWN0XG4gICAgICAgICAgICAgICAgfCBnbG9iYWw6IGdsb2JhbFNlYXJjaFRlcm06ZmlsdGVyZWRDb3VudFN1YmplY3Q7XG4gICAgICAgICAgICAgIGxldCByb3dJbmRleCA9IGluZGV4XG4gICAgICAgICAgICBcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDx0clxuICAgICAgICAgICAgICBbY2xhc3Mubmd4LXRhYmxlX190YWJsZS1yb3ctLXNlbGVjdGVkXT1cIlxuICAgICAgICAgICAgICAgIHJvd0luZGV4ID09PSBzZWxlY3RlZFJvdyAmJiAhY29uZmlnLnNlbGVjdENlbGxcbiAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHRkICpuZ0lmPVwiY29uZmlnLmNoZWNrYm94ZXNcIiB3aWR0aD1cIjMlXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwibmd4LWZvcm0tY2hlY2tib3hcIj5cbiAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICBpZD1cImNoZWNrYm94LWluZmluaXRlLXNjcm9sbC17eyByb3dJbmRleCB9fVwiXG4gICAgICAgICAgICAgICAgICAgIFtjaGVja2VkXT1cImlzU2VsZWN0ZWQgfHwgc2VsZWN0ZWRDaGVja2JveGVzLmhhcyhyb3dJbmRleClcIlxuICAgICAgICAgICAgICAgICAgICAoY2hhbmdlKT1cIm9uQ2hlY2tib3hTZWxlY3QoJGV2ZW50LCByb3csIHJvd0luZGV4KVwiXG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPGVtIGNsYXNzPVwibmd4LWZvcm0taWNvblwiPjwvZW0+XG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgPHRkICpuZ0lmPVwiY29uZmlnLnJhZGlvXCIgd2lkdGg9XCIzJVwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgICAgICAgICBpZD1cInJhZGlvLWluZmluaXRlLXNjcm9sbC17eyByb3dJbmRleCB9fVwiXG4gICAgICAgICAgICAgICAgICAgIG5hbWU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgICAgIChjaGFuZ2UpPVwib25SYWRpb1NlbGVjdCgkZXZlbnQsIHJvdywgcm93SW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGNvbHVtbnM7IGxldCBjb2xJbmRleCA9IGluZGV4XCI+XG4gICAgICAgICAgICAgICAgPHRkXG4gICAgICAgICAgICAgICAgICAoY2xpY2spPVwib25DbGljaygkZXZlbnQsIHJvdywgY29sdW1uLmtleSwgY29sSW5kZXgsIHJvd0luZGV4KVwiXG4gICAgICAgICAgICAgICAgICAjY29udGV4dE1lbnVcbiAgICAgICAgICAgICAgICAgIChjb250ZXh0bWVudSk9XCJvblJvd0NvbnRleHRNZW51KCRldmVudCwgcm93LCBjb2x1bW4ua2V5LCBjb2xJbmRleCwgcm93SW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgIChkYmxjbGljayk9XCJvbkRvdWJsZUNsaWNrKCRldmVudCwgcm93LCBjb2x1bW4ua2V5LCBjb2xJbmRleCwgcm93SW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgIFtjbGFzcy5waW5uZWQtbGVmdF09XCJjb2x1bW4ucGlubmVkXCJcbiAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cImNvbHVtbi5jc3NDbGFzcyA/IGNvbHVtbi5jc3NDbGFzcy5uYW1lIDogJydcIlxuICAgICAgICAgICAgICAgICAgW3N0eWxlLmxlZnRdPVwic3R5bGVTZXJ2aWNlLnBpbm5lZFdpZHRoKGNvbHVtbi5waW5uZWQsIGNvbEluZGV4KVwiXG4gICAgICAgICAgICAgICAgICBbY2xhc3Mubmd4LXRhYmxlX190YWJsZS1jb2wtLXNlbGVjdGVkXT1cIlxuICAgICAgICAgICAgICAgICAgICBjb2xJbmRleCA9PT0gc2VsZWN0ZWRDb2wgJiYgIWNvbmZpZy5zZWxlY3RDZWxsXG4gICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgW2NsYXNzLm5neC10YWJsZV9fdGFibGUtY2VsbC0tc2VsZWN0ZWRdPVwiXG4gICAgICAgICAgICAgICAgICAgIGNvbEluZGV4ID09PSBzZWxlY3RlZENvbCAmJlxuICAgICAgICAgICAgICAgICAgICByb3dJbmRleCA9PT0gc2VsZWN0ZWRSb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgIWNvbmZpZy5zZWxlY3RDb2wgJiZcbiAgICAgICAgICAgICAgICAgICAgIWNvbmZpZy5zZWxlY3RSb3dcbiAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cIiFjb2x1bW4uY2VsbFRlbXBsYXRlXCI+e3sgcm93IHwgcmVuZGVyOiBjb2x1bW4ua2V5IH19PC9kaXY+XG4gICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiY29sdW1uLmNlbGxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbHVtbi5jZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICRpbXBsaWNpdDogcm93LFxuICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4OiByb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJjb25maWcuYWRkaXRpb25hbEFjdGlvbnMgfHwgY29uZmlnLmRldGFpbHNUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cIm5neC1pY29uXCJcbiAgICAgICAgICAgICAgICAgICpuZ0lmPVwiYXJyb3dEZWZpbml0aW9uXCJcbiAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIlxuICAgICAgICAgICAgICAgICAgICBpc1Jvd0NvbGxhcHNlZChyb3dJbmRleCkgPyAnbmd4LWljb24tYXJyb3ctZG93bicgOiAnbmd4LWljb24tYXJyb3ctcmlnaHQnXG4gICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImNvbGxhcHNlUm93KHJvd0luZGV4KVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICA8dHJcbiAgICAgICAgICAgICAgKm5nSWY9XCJcbiAgICAgICAgICAgICAgICAoY29uZmlnLmRldGFpbHNUZW1wbGF0ZSAmJiBzZWxlY3RlZERldGFpbHNUZW1wbGF0ZVJvd0lkLmhhcyhyb3dJbmRleCkpIHx8XG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbGxhcHNlQWxsUm93c1xuICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJjb25maWcuY2hlY2tib3hlcyB8fCBjb25maWcucmFkaW9cIj48L3RkPlxuICAgICAgICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XCJjb2x1bW5zLmxlbmd0aCArIDFcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJkZXRhaWxzVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgJGltcGxpY2l0OiByb3csIGluZGV4OiByb3dJbmRleCB9XCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2Nkay12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydD5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFyb3dUZW1wbGF0ZSAmJiBjb25maWcuZ3JvdXBSb3dzXCI+XG4gICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAqbmdGb3I9XCJcbiAgICAgICAgICAgIGxldCBncm91cCBvZiBncm91cGVkXG4gICAgICAgICAgICAgIHwgc29ydDogc29ydEJ5OmNvbmZpZ1xuICAgICAgICAgICAgICB8IHNlYXJjaDogdGVybTpmaWx0ZXJlZENvdW50U3ViamVjdDpjb25maWdcbiAgICAgICAgICAgICAgfCBnbG9iYWw6IGdsb2JhbFNlYXJjaFRlcm06ZmlsdGVyZWRDb3VudFN1YmplY3RcbiAgICAgICAgICAgICAgfCBwYWdpbmF0ZTogeyBpdGVtc1BlclBhZ2U6IGxpbWl0LCBjdXJyZW50UGFnZTogcGFnZSwgdG90YWxJdGVtczogY291bnQsIGlkOiBpZCB9O1xuICAgICAgICAgICAgbGV0IHJvd0luZGV4ID0gaW5kZXhcbiAgICAgICAgICBcIlxuICAgICAgICA+XG4gICAgICAgICAgPHRyPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFncm91cFJvd3NIZWFkZXJUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XCJjb2x1bW5zLmxlbmd0aFwiPlxuICAgICAgICAgICAgICAgIDxkaXY+e3sgZ3JvdXBbMF1bZ3JvdXBSb3dzQnldIH19ICh7eyBncm91cC5sZW5ndGggfX0pPC9kaXY+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgKm5nSWY9XCJncm91cFJvd3NIZWFkZXJUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImdyb3VwUm93c0hlYWRlclRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICB0b3RhbDogZ3JvdXAubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGtleTogZ3JvdXBSb3dzQnksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwWzBdID8gZ3JvdXBbMF1bZ3JvdXBSb3dzQnldIDogJycsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwLFxuICAgICAgICAgICAgICAgIGluZGV4OiByb3dJbmRleFxuICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgIGNsYXNzPVwibmd4LWljb25cIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwiYXJyb3dEZWZpbml0aW9uXCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJcbiAgICAgICAgICAgICAgICAgIGlzUm93Q29sbGFwc2VkKHJvd0luZGV4KSA/ICduZ3gtaWNvbi1hcnJvdy1kb3duJyA6ICduZ3gtaWNvbi1hcnJvdy1yaWdodCdcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJjb2xsYXBzZVJvdyhyb3dJbmRleClcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic2VsZWN0ZWREZXRhaWxzVGVtcGxhdGVSb3dJZC5oYXMocm93SW5kZXgpXCI+XG4gICAgICAgICAgICA8dHIgKm5nRm9yPVwibGV0IHJvdyBvZiBncm91cFwiPlxuICAgICAgICAgICAgICA8dGQgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBjb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAge3sgcm93IHwgcmVuZGVyOiBjb2x1bW4ua2V5IH19XG4gICAgICAgICAgICAgICAgPCEtLSBUT0RPIGFsbG93IHVzZXJzIHRvIGFkZCBncm91cFJvd3NUZW1wbGF0ZVJlZiAtLT5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgPHRkPjwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvdGJvZHk+XG4gICAgPHRib2R5XG4gICAgICAqbmdJZj1cImRhdGEgJiYgIWNvbmZpZy5pc0xvYWRpbmcgJiYgY29uZmlnLnJvd1Jlb3JkZXJcIlxuICAgICAgY2xhc3M9XCJuZ3gtZHJhZ2dhYmxlLXJvdy1hcmVhXCJcbiAgICAgIGNka0Ryb3BMaXN0XG4gICAgICAoY2RrRHJvcExpc3REcm9wcGVkKT1cIm9uRHJvcCgkZXZlbnQpXCJcbiAgICA+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXJvd1RlbXBsYXRlICYmICFjb25maWcuZ3JvdXBSb3dzXCI+XG4gICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAqbmdGb3I9XCJcbiAgICAgICAgICAgIGxldCByb3cgb2YgZGF0YVxuICAgICAgICAgICAgICB8IHNvcnQ6IHNvcnRCeVxuICAgICAgICAgICAgICB8IHNlYXJjaDogdGVybTpmaWx0ZXJlZENvdW50U3ViamVjdFxuICAgICAgICAgICAgICB8IGdsb2JhbDogZ2xvYmFsU2VhcmNoVGVybTpmaWx0ZXJlZENvdW50U3ViamVjdFxuICAgICAgICAgICAgICB8IHBhZ2luYXRlOiB7IGl0ZW1zUGVyUGFnZTogbGltaXQsIGN1cnJlbnRQYWdlOiBwYWdlLCB0b3RhbEl0ZW1zOiBjb3VudCwgaWQ6IGlkIH1cbiAgICAgICAgICBcIlxuICAgICAgICA+XG4gICAgICAgICAgPHRyXG4gICAgICAgICAgICBjbGFzcz1cIm5neC1kcmFnZ2FibGUtcm93XCJcbiAgICAgICAgICAgIGNka0RyYWdcbiAgICAgICAgICAgIChjZGtEcmFnU3RhcnRlZCk9XCJvbkRyYWdTdGFydCgkZXZlbnQpXCJcbiAgICAgICAgICAgIFtjZGtEcmFnU3RhcnREZWxheV09XCJjb25maWcucmVvcmRlckRlbGF5IHx8IDBcIlxuICAgICAgICAgICAgY2RrRHJhZ0xvY2tBeGlzPVwieVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHRkICpuZ0lmPVwiY29uZmlnLmNoZWNrYm94ZXNcIj5cbiAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwibmd4LWZvcm0tY2hlY2tib3hcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICBpZD1cImNoZWNrYm94LWRyYWdnYWJsZS17eyBkYXRhLmluZGV4T2Yocm93KSB9fVwiXG4gICAgICAgICAgICAgICAgICBbY2hlY2tlZF09XCJpc1NlbGVjdGVkIHx8IHNlbGVjdGVkQ2hlY2tib3hlcy5oYXMoZGF0YS5pbmRleE9mKHJvdykpXCJcbiAgICAgICAgICAgICAgICAgIChjaGFuZ2UpPVwib25DaGVja2JveFNlbGVjdCgkZXZlbnQsIHJvdywgZGF0YS5pbmRleE9mKHJvdykpXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxlbSBjbGFzcz1cIm5neC1mb3JtLWljb25cIj48L2VtPlxuICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZCAqbmdJZj1cImNvbmZpZy5yYWRpb1wiPlxuICAgICAgICAgICAgICA8bGFiZWw+XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgICAgICAgaWQ9XCJyYWRpby1kcmFnZ2FibGUte3sgZGF0YS5pbmRleE9mKHJvdykgfX1cIlxuICAgICAgICAgICAgICAgICAgbmFtZT1cInJhZGlvXCJcbiAgICAgICAgICAgICAgICAgIChjaGFuZ2UpPVwib25SYWRpb1NlbGVjdCgkZXZlbnQsIHJvdywgZGF0YS5pbmRleE9mKHJvdykpXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBjb2x1bW5zOyBsZXQgY29sSW5kZXggPSBpbmRleFwiPlxuICAgICAgICAgICAgICA8dGRcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwib25DbGljaygkZXZlbnQsIHJvdywgY29sdW1uLmtleSwgY29sSW5kZXgsIGRhdGEuaW5kZXhPZihyb3cpKVwiXG4gICAgICAgICAgICAgICAgKGRibGNsaWNrKT1cIm9uRG91YmxlQ2xpY2soJGV2ZW50LCByb3csIGNvbHVtbi5rZXksIGNvbEluZGV4LCBkYXRhLmluZGV4T2Yocm93KSlcIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5uZ3gtdGFibGVfX3RhYmxlLWNvbC0tc2VsZWN0ZWRdPVwiXG4gICAgICAgICAgICAgICAgICBjb2xJbmRleCA9PT0gc2VsZWN0ZWRDb2wgJiYgIWNvbmZpZy5zZWxlY3RDZWxsXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Mubmd4LXRhYmxlX190YWJsZS1jZWxsLS1zZWxlY3RlZF09XCJcbiAgICAgICAgICAgICAgICAgIGNvbEluZGV4ID09PSBzZWxlY3RlZENvbCAmJlxuICAgICAgICAgICAgICAgICAgZGF0YS5pbmRleE9mKHJvdykgPT09IHNlbGVjdGVkUm93ICYmXG4gICAgICAgICAgICAgICAgICAhY29uZmlnLnNlbGVjdENvbCAmJlxuICAgICAgICAgICAgICAgICAgIWNvbmZpZy5zZWxlY3RSb3dcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cIiFjb2x1bW4uY2VsbFRlbXBsYXRlXCI+e3sgcm93IHwgcmVuZGVyOiBjb2x1bW4ua2V5IH19PC9kaXY+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgKm5nSWY9XCJjb2x1bW4uY2VsbFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbHVtbi5jZWxsVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiByb3csXG4gICAgICAgICAgICAgICAgICAgIHJvd0luZGV4OiBkYXRhLmluZGV4T2Yocm93KSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC90Ym9keT5cbiAgICA8dGJvZHkgKm5nSWY9XCJmaWx0ZXJDb3VudCA9PT0gMFwiPlxuICAgICAgPHRyIGNsYXNzPVwibmd4LXRhYmxlX19ib2R5LWVtcHR5XCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJub1Jlc3VsdHNUZW1wbGF0ZVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm5vUmVzdWx0c1RlbXBsYXRlXCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XCJjb2x1bW5zICYmIGNvbHVtbnMubGVuZ3RoICsgMVwiICpuZ0lmPVwiIW5vUmVzdWx0c1RlbXBsYXRlXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5neC10YWJsZV9fdGFibGUtbm8tcmVzdWx0c1wiPk5vIHJlc3VsdHM8L2Rpdj5cbiAgICAgICAgPC90ZD5cbiAgICAgIDwvdHI+XG4gICAgPC90Ym9keT5cbiAgICA8dGJvZHkgKm5nSWY9XCJjb25maWcuaXNMb2FkaW5nXCI+XG4gICAgICA8dHIgY2xhc3M9XCJuZ3gtdGFibGVfX2JvZHktbG9hZGluZ1wiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibG9hZGluZ1RlbXBsYXRlXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwibG9hZGluZ1RlbXBsYXRlXCI+IDwvbmctY29udGFpbmVyPlxuICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XCJjb2x1bW5zICYmIGNvbHVtbnMubGVuZ3RoICsgMVwiICpuZ0lmPVwiIWxvYWRpbmdUZW1wbGF0ZVwiPlxuICAgICAgICAgIDxkaXYgW3N0eWxlLmhlaWdodC5weF09XCJsb2FkaW5nSGVpZ2h0XCIgY2xhc3M9XCJuZ3gtdGFibGVfX3RhYmxlLWxvYWRlci13cmFwcGVyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmd4LXRhYmxlX190YWJsZS1sb2FkZXJcIj48L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC90ZD5cbiAgICAgIDwvdHI+XG4gICAgPC90Ym9keT5cbiAgICA8dGZvb3QgKm5nSWY9XCJzdW1tYXJ5VGVtcGxhdGVcIj5cbiAgICAgIDx0cj5cbiAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInN1bW1hcnlUZW1wbGF0ZVwiXG4gICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgdG90YWw6IGRhdGEubGVuZ3RoLCBsaW1pdDogbGltaXQsIHBhZ2U6IHBhZ2UgfVwiXG4gICAgICAgID5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICA8L3RyPlxuICAgIDwvdGZvb3Q+XG4gIDwvdGFibGU+XG4gIDxwYWdpbmF0aW9uXG4gICAgW2F0dHIuaWRdPVwiJ3BhZ2luYXRpb24nICsgaWRcIlxuICAgIFtpZF09XCJpZFwiXG4gICAgI3BhZ2luYXRpb25Db21wb25lbnRcbiAgICBbY29uZmlnXT1cImNvbmZpZ1wiXG4gICAgW3BhZ2luYXRpb25dPVwicGFnaW5hdGlvblwiXG4gICAgKHVwZGF0ZVJhbmdlKT1cIm9uUGFnaW5hdGlvbigkZXZlbnQpXCJcbiAgPlxuICA8L3BhZ2luYXRpb24+XG48L2Rpdj5cbiJdfQ==